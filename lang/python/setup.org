* Fix python-mode's send region
** Elpy's send region works well for arbitrary regions use it instead
   #+begin_src emacs-lisp
     (defun elpy--region-without-indentation (beg end)
       "Return the current region as a string, but without indentation."
       (let ((region (buffer-substring beg end))
             (indent-level nil))
         (catch 'return
           (with-temp-buffer
             (insert region)
             (goto-char (point-min))
             (while (< (point) (point-max))
               (cond
                ((and (not indent-level)
                      (not (looking-at "[ \t]*$")))
                 (setq indent-level (current-indentation)))
                ((and indent-level
                      (not (looking-at "[ \t]*$"))
                      (< (current-indentation)
                         indent-level))
                 (error "Can't adjust indentation, consecutive lines indented less than starting line")))
               (forward-line))
             (indent-rigidly (point-min)
                             (point-max)
                             (- indent-level))
             (buffer-string)))))
   #+end_src

** Custom functions for sending regions based on elpy's code
   #+begin_src emacs-lisp
     (defun iqbal-py-send-region (beg end)
       (interactive "r")
       (python-shell-send-string (elpy--region-without-indentation beg end)))
     
     (defun iqbal-py-send-line ()
       (interactive)
       (python-shell-send-string (elpy--region-without-indentation (line-beginning-position)
                                                                   (line-end-position))))
   #+end_src


* Separate functions for moving to start/end of function and class
** A modified version of python-mode's python-nav-end-of-defun
   #+begin_src emacs-lisp
     (defun iqbal-python-nav-end-of-defun ()
       "Move point to the end of def or class.
     Returns nil if point is not in a def or class."
       (interactive)
       (let ((beg-defun-indent)
             (beg-pos (point)))
         (when (or (python-info-looking-at-beginning-of-defun)
                   (python-nav-beginning-of-defun -1)
                   (python-nav-beginning-of-defun 1))
           (setq beg-defun-indent (current-indentation))
           (while (progn
                    (python-nav-end-of-statement)
                    (python-util-forward-comment 1)
                    (and (> (current-indentation) beg-defun-indent)
                         (not (eobp)))))
           (python-util-forward-comment -1)
           (forward-line 1)
           ;; Ensure point moves forward.
           (and (> beg-pos (point)) (goto-char beg-pos)))))
   #+end_src

** Function for moving at start of class
  #+begin_src emacs-lisp
    (defun iqbal-py-begining-of-class (&optional args)
      (interactive "p")
      (let ((python-nav-beginning-of-defun-regexp "^[[:space:]]*\\_<\\(?:class\\)\\_>[[:space:]]+\\([_[:alpha:]][_[:word:]]*\\)"))
        (python-nav-beginning-of-defun args)))
  #+end_src

** Function for moving at end of class
   #+begin_src emacs-lisp
     (defun iqbal-py-end-of-class ()
       (interactive)
       (let ((python-nav-beginning-of-defun-regexp "^[[:space:]]*\\_<\\(?:class\\)\\_>[[:space:]]+\\([_[:alpha:]][_[:word:]]*\\)"))
         (iqbal-python-nav-end-of-defun)))
   #+end_src

** Function for moving at start of function
   #+begin_src emacs-lisp
     (defun iqbal-py-begining-of-defun (&optional args)
       (interactive "p")
       (let ((python-nav-beginning-of-defun-regexp "^[[:space:]]*\\_<\\(?:def\\)\\_>[[:space:]]+\\([_[:alpha:]][_[:word:]]*\\)"))
         (python-nav-beginning-of-defun args)))
   #+end_src

** Function for moving at end of function
   #+begin_src emacs-lisp
     (defun iqbal-py-end-of-defun ()
       (interactive)
       (let ((python-nav-beginning-of-defun-regexp "^[[:space:]]*\\_<\\(?:def\\)\\_>[[:space:]]+\\([_[:alpha:]][_[:word:]]*\\)"))
         (iqbal-python-nav-end-of-defun)))
   #+end_src


* Setup Jedi for autocompletion
** Configuration
  Automatically start completion after inserting a dot
  #+begin_src emacs-lisp
    (setq jedi:complete-on-dot t)
  #+end_src

** Setup jedi for current buffer
   We simply need to call jedi:setup
   #+begin_src emacs-lisp
       (jedi:setup)
   #+end_src


* Setup Rope for refactoring
** Functions for finding current python modules and generating auto-import cache
   #+begin_src emacs-lisp
     (defvar iqbal-python-modules-code "python -c 'import pkgutil; print tuple([i[1] for i in pkgutil.iter_modules()])'")
     
     (defun iqbal-parse-and-store-python-modules (buffer file)
       (with-current-buffer buffer
         ;; Replace all ' with " to make them lisp strings
         (goto-char (point-min))
         (while (search-forward "'" nil t)
           (replace-match "\"" nil t))
     
         (goto-char (point-min))
         (while (search-forward "," nil t)
           (replace-match "" nil t))
         
         (iqbal-write-to-file file (buffer-string))))
     
     (defun iqbal-read-existing-python-modules (callback)
       (with-current-buffer (get-buffer-create "python-modules")
         (erase-buffer))
       (set-process-sentinel (start-process-shell-command "python-modules"
                                                          "python-modules"
                                                          iqbal-python-modules-code)
                             callback))
     
     (defun iqbal--generate-auto-import-cache (project-dir &optional force)
       (lexical-let ((modules-file (when project-dir
                                     (concat project-dir "/.modules"))))
         (when (and modules-file
                    (or force
                        (not (file-exists-p modules-file))))
     
           (iqbal-read-existing-python-modules (lambda (proc state)
                                                 (when (equal state "finished\n")
                                                   (iqbal-parse-and-store-python-modules (process-buffer proc) modules-file)
                                                   (setq ropemacs-autoimport-modules (read (iqbal-read-file modules-file)))
                                                   (rope-generate-autoimport-cache)))))))
     
     (defun iqbal-generate-auto-import-cache (force)
       (interactive (list t))
       (let ((project-dir (or (locate-dominating-file (buffer-file-name) ".ropeproject")
                              (ignore-errors (projectile-project-root)))))
         (if project-dir
             (iqbal--generate-auto-import-cache project-dir force)
           (message "Not in a project"))))
   #+end_src

** Configuration
   1. Prevent rope from setting up keybindings, we'll set our keybindings
   #+begin_src emacs-lisp
     (setq ropemacs-enable-shortcuts nil)
     (setq ropemacs-local-prefix nil)
     (setq ropemacs-global-prefix nil)
   #+end_src
   
   2. Enable autoimport
   #+begin_src emacs-lisp
     (setq ropemacs-enable-autoimport t)
   #+end_src
   
** Start ropemacs
   Load pymacs and load rope, if not already loaded
   #+begin_src emacs-lisp
     (unless (featurep 'pymacs)
       (load "pymacs")
       (pymacs-load "ropemacs" "rope-"))
   #+end_src

** Generate auto-import cache if not generated already
   #+begin_src emacs-lisp
     (iqbal-generate-auto-import-cache nil)
   #+end_src

** If a ropeproject is not created always create it at the projectile-project-root
   To open a different project use 'iqbal-open-rope-project'
   #+begin_src emacs-lisp
     (defadvice rope-open-project (around iqbal-use-projectile (&optional root))
       (ad-set-arg 0 (if (not root)
                       (ignore-errors (projectile-project-root))
                       root))
       ad-do-it)
     
     (ad-activate 'rope-open-project)
     
     (defun iqbal-open-rope-project (root)
       (interactive  "D")
       (rope-open-project root))
   #+end_src

  
* Setup flycheck for error checking
** Enable flycheck-mode
  #+begin_src emacs-lisp
    (flycheck-mode)
  #+end_src
  
** Use pylint for syntax checking
   #+begin_src emacs-lisp
     (flycheck-select-checker 'python-pylint)
   #+end_src


* Use django style comments with fill-column
  #+begin_src emacs-lisp
    (setq python-fill-docstring-style 'django)
  #+end_src


* Use nosetests for testing
  #+begin_src emacs-lisp
    (when (locate-library "nose")
      (load "nose"))
  #+end_src


* Setup code folding
  Enable "hs-minor-mode"
  #+begin_src emacs-lisp 
    (hs-minor-mode)
  #+end_src


* Use ipython if available
  #+begin_src emacs-lisp
    (when (executable-find "ipython") 
      (setq
       python-shell-interpreter "ipython"
       python-shell-prompt-regexp "In \\[[0-9]+\\]: "
       python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "
       python-shell-completion-setup-code
       "from IPython.core.completerlib import module_completion"
       python-shell-completion-module-string-code
       "';'.join(module_completion('''%s'''))\n"
       python-shell-completion-string-code
       "';'.join(get_ipython().Completer.all_completions('''%s'''))\n"))
  #+end_src


* Flash current line after a jump to definition
  #+begin_src emacs-lisp
    (defadvice jedi:goto-definition (after highlight-current-line
                                           (&optional other-window deftype use-cache index))
      "Flash the current line after jedi jump"
      (sit-for 0.1)
      (iqbal-highlight-line))
    
    (ad-activate 'jedi:goto-definition)
  #+end_src
