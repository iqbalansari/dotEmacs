* Enable gtags-mode
  #+begin_src emacs-lisp
    (when my-gtags-available
      (gtags-mode))
  #+end_src


* Enable prepaint mode
  #+begin_src emacs-lisp
    (preproc-font-lock-global-mode 1)
  #+end_src


* Load rtags and start rdm
  #+begin_src emacs-lisp
    (when my-rtags-available
      (unless (fboundp 'rtags-start-process-maybe)
        (load "rtags"))
    
      (rtags-start-process-maybe))
  #+end_src


* Check if project is indexed
  #+begin_src emacs-lisp
    (make-local-variable 'my-rtags-project-indexed)

    (when my-rtags-available
      (let* ((project-root (ignore-errors (projectile-project-root)))
             (rtags-status (shell-command-to-string (concat (rtags-executable-find "rc")
                                                            " --is-indexed "
                                                            buffer-file-name)))
             (project-indexed (string= rtags-status "indexed\n")))
        (if project-indexed
            (setq my-rtags-project-indexed project-indexed)
          (let ((compile-commands (my-locate-compile-commands project-root)))
            (if compile-commands
                (shell-command (format "%s -J %s"
                                       (rtags-executable-find "rc")
                                       (shell-quote-argument compile-commands)))
              (warn "compile_commands.json not found for this project"))))))
  #+end_src


* Create GTAGS/TAGS if not created yet and RTags is not available for the project
  #+begin_src emacs-lisp
    (let ((project-root (ignore-errors (projectile-project-root))))
      (when (and project-root (not my-rtags-project-indexed))
        (cond (my-gtags-available (progn
                                    (unless (file-exists-p (concat project-root "GTAGS"))
                                    (shell-command (concat "cd "
                                                           (shell-quote-argument project-root)
                                                           " && gtags")))))
              ((executable-find "etags") (unless  (file-exists-p (concat project-root "TAGS"))
                                           (shell-command (concat "cd "
                                                                  (shell-quote-argument project-root)
                                                                  " && find . -name \"*.[ch]\" -print | xargs etags -a ")))))))
  #+end_src


* Automatically jump to symbol under cursor in *RTags* buffer
  #+begin_src emacs-lisp
    (setq rtags-error-timer-interval 0.1)
    (setq rtags-tracking t)
  #+end_src


* Highlight line after jump to definition
   #+begin_src emacs-lisp
     (my-highlight-line-after-func my-c-find-definition-rtags)
     (my-highlight-line-after-func my-find-definition-rtags-fallback)
     (my-highlight-line-after-func gtags-find-tag)
     (my-highlight-line-after-func find-tag)
   #+end_src


* Setup auto-completion
   Also add company-c-headers to company-backends
   #+begin_src emacs-lisp
     (when my-irony-available
       (irony-mode)
       (add-to-list 'company-backends '(company-irony company-c-headers))
       (company-irony-setup-begin-commands))
   #+end_src


* Setup eldoc
  #+begin_src emacs-lisp
    (when my-irony-available
      (irony-eldoc))
  #+end_src


* Setup syntax checking
** Enable flycheck mode
  #+begin_src emacs-lisp
    (flycheck-mode)
  #+end_src

** Select whichever checker is available
   #+begin_src emacs-lisp
     (flycheck-select-checker (cond ((and my-gcc-version (not (version< my-gcc-version "4.8.1"))) 'c/c++-gcc)
                                    (my-clang-version 'c/c++-clang)))
   #+end_src

  #+begin_src emacs-lisp
    (eval-after-load 'projectile
      '(add-to-list 'projectile-project-root-files "compile_commands.json"))
  #+end_src
