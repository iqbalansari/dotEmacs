* Enable gtags-mode
  #+begin_src emacs-lisp
    (when my-gtags-available
      (gtags-mode))
  #+end_src


* Enable prepaint mode
  #+begin_src emacs-lisp
    (prepaint-mode)
  #+end_src


* Load rtags and start rdm
  #+begin_src emacs-lisp
    (when my-rtags-available
      (unless (fboundp 'rtags-start-process-maybe)
        (load "rtags"))
    
      (rtags-start-process-maybe))
  #+end_src


* Create GTAGS/TAGS if not created yet
  #+begin_src emacs-lisp
    (let ((project-root (ignore-errors (projectile-project-root))))
      (when project-root
        (cond (my-gtags-available (unless (file-exists-p (concat project-root "GTAGS"))
                                    (shell-command (concat "cd "
                                                           project-root
                                                           " && gtags"))))
              ((executable-find "etags") (unless  (file-exists-p (concat project-root "TAGS"))
                                           (shell-command (concat "cd "
                                                                  project-root
                                                                  " && find . -name \"*.[ch]\" -print | xargs etags -a ")))))))
  #+end_src


* Automatically jump to symbol under cursor in *RTags* buffer
  #+begin_src emacs-lisp
    (setq rtags-error-timer-interval 0.1)
    (setq rtags-tracking t)
  #+end_src


* Load malinka
  #+begin_src emacs-lisp
    (when (and (not (boundp 'malinka-projects-map))
               (locate-library "malinka"))
      (load "malinka")
      (when (file-exists-p (locate-user-emacs-file "malinka-projects.el"))
        (load (locate-user-emacs-file "malinka-projects.el"))))
  #+end_src


* Index files if not already indexed
  #+begin_src emacs-lisp
    (defvar my-rtags-project-indexed nil)
    (make-local-variable 'my-rtags-project-indexed)

    (defun my-may-be-index-c-project (buffer)
      (when my-rtags-available
        (with-current-buffer buffer
          (let* ((project-root (ignore-errors (projectile-project-root)))
                 (project-map (when project-root
                                (car (loop for project-map in malinka-projects-map
                                           when (string-equal (cdr (assoc 'root-directory project-map)) project-root)
                                           collect project-map)))))
            (if (not project-map)
                (warn (concat "Project not configured, please add malinka-define-project directive\n"
                              "to ~/.emacs.d/malinka-projects.el see http://github.com/LefterisJP/malinka for syntax"))
              (when (zerop (string-to-number (shell-command-to-string (concat (rtags-executable-find "rc")
                                                                              " --has-filemanager "
                                                                              project-root))))
                (message (concat "Indexing project, this may take some time, this happens just once per project."
                                 " You can manually invoke indexing with malinka-configure-project."
                                 "\nThe result of indexing can be seen in *rdm* buffer"))
                (malinka-project-configure (cdr (assoc 'name project-map))
                                           project-root))
              (setq-local my-rtags-project-indexed t))))))

    (run-at-time 0.1 nil #'my-may-be-index-c-project (current-buffer))
  #+end_src


* Setup jump to definition
** Custom jump to definition function using rtags
  Try to use rtags, if it fails fallback to gtags, if gtags is not available use
  etags TODO: Does not work properly yet
  #+begin_src emacs-lisp
    (defun my-find-definition-rtags-fallback ()
      (with-current-buffer rtags-buffer-name
        (when (= (point-min) (point-max))
          (if rtags-last-request-not-indexed
              (if my-gtags-available (gtags-find-tag) (call-interactively #'find-tag))
            (rtags-find-symbols-by-name-internal "No obvious location found for jump, find symbol"
                                                 "-F")))))
    
    (defun my-c-find-definition-rtags (&optional prefix)
      (interactive "P")
      (rtags-find-symbol-at-point prefix)
      (my-find-definition-rtags-fallback))
    
    (defun my-c-find-definition (&optional prefix)
      (interactive "P")
      (cond (my-rtags-project-indexed (call-interactively #'my-c-find-definition-rtags))
            (my-gtags-available (call-interactively  #'gtags-find-tag))
            (t (call-interactively  #'find-tag))))
    
    (defun my-c-pop-mark ()
      (interactive)
      (cond (my-rtags-project-indexed (call-interactively #'rtags-location-stack-back))
            (my-gtags-available (call-interactively #'gtags-pop-stack))
            (t (call-interactively #'pop-tag-mark))))
  #+end_src

** Highlight line after jump
   #+begin_src emacs-lisp
     (my-highlight-line-after-func my-c-find-definition-rtags)
     (my-highlight-line-after-func my-find-definition-rtags-fallback)
     (my-highlight-line-after-func gtags-find-tag)
     (my-highlight-line-after-func find-tag)
   #+end_src


* Find references
  #+begin_src emacs-lisp
    (defun my-c-find-references ()
      (interactive)
      (cond (my-rtags-project-indexed (call-interactively #'rtags-find-references))
            (my-gtags-available (call-interactively #'gtags-find-rtag))
            (t (call-interactively #'rgrep))))
  #+end_src


* Setup auto-completion
** Disable auto-complete and enable company mode
   Also add company-c-headers to company-backends
   #+begin_src emacs-lisp
     (when my-irony-available
       (auto-complete-mode -1)
       (company-mode)
       (irony-mode)
       (add-to-list 'company-backends 'company-irony)
       (company-irony-setup-begin-commands)
       (add-to-list 'company-backends 'company-c-headers))
   #+end_src


* Setup syntax checking
** Enable flycheck mode
  #+begin_src emacs-lisp
    (flycheck-mode)
  #+end_src

** Select whichever checker is available
   #+begin_src emacs-lisp
     (flycheck-select-checker (cond ((not (version< my-gcc-version "4.8.1")) 'c/c++-gcc)
                                    (my-clang-version 'c/c++-clang)))
   #+end_src


* Use .compile_commands.json files to identify project roots in projectile
  #+begin_src emacs-lisp
    (eval-after-load 'projectile
      '(add-to-list 'projectile-project-root-files ".compile_commands.json"))
  #+end_src
