* Some additional packages for working with dired
  #+begin_src emacs-lisp
    (defvar my-dired-packages '(dired-details dired-single neotree))
    (my-install-packages my-dired-packages)
  #+end_src


* Load dired-x for additional functionality
  #+begin_src emacs-lisp
    (load "dired-x")
  #+end_src


* Keybinding for neotree
  #+begin_src emacs-lisp
    (autoload 'neotree-toggle "neotree")
    (global-set-key (kbd "C-c z") 'neotree-toggle)
  #+end_src


* Allow recursive delete, after asking for each directory at top level
  #+begin_src emacs-lisp
    (setq dired-recursive-deletes 'top)
  #+end_src


* Copy recursively without asking
  #+begin_src emacs-lisp
    (setq dired-recursive-copies 'always)
  #+end_src


* Auto revert dired buffer on revisiting
  #+begin_src emacs-lisp
    (setq dired-auto-revert-buffer t)
  #+end_src


* Let dired guess the target directory
  #+begin_src emacs-lisp
    (setq dired-dwim-target t)
  #+end_src


* Isearch in file names only, if when initial point position is on a file name
  #+begin_src emacs-lisp
    (setq dired-isearch-filenames 'dwim)
  #+end_src


* Display human-readable sizes in dired
  #+begin_src emacs-lisp
    (setq dired-listing-switches "-lah")
  #+end_src


* When in dired jump to start and end of directory listing (not the dired buffer)
  #+begin_src emacs-lisp
    (defun dired-jump-to-bottom ()
      (interactive)
      (goto-char (point-max))
      (dired-next-line -1))

    (defun dired-back-to-top ()
      (interactive)
      (goto-char (point-min))
      (dired-next-line 3))

    (eval-after-load "dired"
      '(progn (define-key dired-mode-map
                (vector 'remap 'beginning-of-buffer) 'dired-back-to-top)

              (define-key dired-mode-map
                (vector 'remap 'end-of-buffer) 'dired-jump-to-bottom)))
  #+end_src


* Dired-details configuration
  #+begin_src emacs-lisp
    (add-hook 'dired-mode-hook
              (lambda ()
                (load "dired-details")
                (dired-details-install)
                (setq dired-details-hidden-string "[..] ")))
  #+end_src


* Dired-single configuration as recommended in dired-single.el
  #+begin_src emacs-lisp
    (defun my-dired-init ()
      "Bunch of stuff to run for dired, either immediately or when it's
            loaded."
      (define-key dired-mode-map (kbd "RET") 'dired-single-buffer)
      (define-key dired-mode-map [mouse-1] 'dired-single-buffer-mouse)
      (define-key dired-mode-map "^"
        (function
         (lambda nil (interactive) (dired-single-buffer "..")))))

    ;; if dired's already loaded, then the keymap will be bound
    (if (boundp 'dired-mode-map)
        ;; we're good to go; just add our bindings
        (my-dired-init)
      ;; it's not loaded yet, so add our bindings to the load-hook
      (add-hook 'dired-load-hook 'my-dired-init))
  #+end_src


* Wdired configuration
  #+begin_src emacs-lisp
    (autoload 'wdired-change-to-wdired-mode "wdired")
    (setq wdired-use-interactive-rename t)
    (setq wdired-confirm-overwrite t)
    (setq wdired-use-dired-vertical-movement t)
  #+end_src


* Keybinding to enable wdired mode
  #+begin_src emacs-lisp
    (add-hook 'dired-mode-hook (lambda ()
                                 (define-key dired-mode-map "e" #'dired-toggle-read-only)))
  #+end_src


* Keybindings for starting dired
  #+begin_src emacs-lisp
    (global-set-key (kbd "C-x C-d") 'ido-dired)
  #+end_src
