* Use switch-window for switching between windows
  #+begin_src emacs-lisp
    (el-get 'sync 'switch-window)
    (global-set-key (kbd "C-x o") 'switch-window)
  #+end_src
  

* Function to rename current buffer and associated file taken from
  [[http://whattheemacsd.com/file-defuns.el-01.html][whattheemacsd]].
  #+begin_src emacs-lisp
    (defun rename-current-buffer-file ()
      "Renames current buffer and file it is visiting."
      (interactive)
      (let ((name (buffer-name))
            (filename (buffer-file-name)))
        (if (not (and filename (file-exists-p filename)))
            (error "Buffer '%s' is not visiting a file!" name)
          (let ((new-name (read-file-name "New name: " filename)))
            (if (get-buffer new-name)
                (error "A buffer named '%s' already exists!" new-name)
              (rename-file filename new-name 1)
              (rename-buffer new-name)
              (set-visited-file-name new-name)
              (set-buffer-modified-p nil)
              (message "File '%s' successfully renamed to '%s'"
                       name (file-name-nondirectory new-name)))))))
    
    (global-set-key (kbd "C-x C-r") 'rename-current-buffer-file)
  #+end_src


* Function to delete current buffer and its associated file
  #+begin_src emacs-lisp
    (defun delete-file-and-buffer ()
      "Kill the current buffer and deletes the file it is visiting."
      (interactive)
      (let ((filename (buffer-file-name)))
        (when filename
          (if (vc-backend filename)
              (vc-delete-file filename)
            (progn
              (delete-file filename)
              (message "Deleted file %s" filename)
              (kill-buffer))))))
  #+end_src
  
  
* Replace the current expression with the result of its evaluation
  #+begin_src emacs-lisp
    (defun eval-and-replace ()
      "Replace the preceding sexp with its value."
      (interactive)
      (backward-kill-sexp)
      (condition-case nil
          (prin1 (eval (read (current-kill 0)))
                 (current-buffer))
        (error (message "Invalid expression")
               (insert (current-kill 0)))))
    
    (global-set-key (kbd "C-c e") 'eval-and-replace)
  #+end_src
  

* Keybinding for starting proced
  #+begin_src emacs-lisp
    (global-set-key (kbd "C-x C-p") 'proced)
  #+end_src
  

* Functions for swapping and toggling current windows
  I don't currently remember where I got these from
  #+begin_src emacs-lisp
    (defun my-swap-windows ()
      "If you have 2 windows, it swaps them."
      (interactive)
      (cond ((not (= (count-windows) 2))
             (message "You need exactly 2 windows to do this."))
            (t
             (let* ((w1 (first (window-list)))
                    (w2 (second (window-list)))
                    (b1 (window-buffer w1))
                    (b2 (window-buffer w2))
                    (s1 (window-start w1))
                    (s2 (window-start w2)))
               (set-window-buffer w1 b2)
               (set-window-buffer w2 b1)
               (set-window-start w1 s2)
               (set-window-start w2 s1)))))
    
    (defun my-toggle-window-split ()
      "Vertical split shows more of each line, horizontal split shows
    more lines. This code toggles between them. It only works for
    frames with exactly two windows."
      (interactive)
      (if (= (count-windows) 2)
          (let* ((this-win-buffer (window-buffer))
                 (next-win-buffer (window-buffer (next-window)))
                 (this-win-edges (window-edges (selected-window)))
                 (next-win-edges (window-edges (next-window)))
                 (this-win-2nd (not (and (<= (car this-win-edges)
                                             (car next-win-edges))
                                         (<= (cadr this-win-edges)
                                             (cadr next-win-edges)))))
                 (splitter
                  (if (= (car this-win-edges)
                         (car (window-edges (next-window))))
                      'split-window-horizontally
                    'split-window-vertically)))
            (delete-other-windows)
            (let ((first-win (selected-window)))
              (funcall splitter)
              (if this-win-2nd (other-window 1))
              (set-window-buffer (selected-window) this-win-buffer)
              (set-window-buffer (next-window) next-win-buffer)
              (select-window first-win)
              (if this-win-2nd (other-window 1))))))
    
    (global-set-key (kbd "C-c w t") 'my-toggle-window-split)
    (global-set-key (kbd "C-c w s") 'my-swap-windows)
  #+end_src
  
  
* Cleanup whitespace in the buffer
  #+begin_src emacs-lisp
    (defun cleanup-buffer-safe ()
      "Perform a bunch of safe operations on the whitespace content of a buffer.
    Does not indent buffer, because it is used for a before-save-hook, and that
    might be bad."
      (interactive)
      (untabify (point-min) (point-max))
      (delete-trailing-whitespace)
      (set-buffer-file-coding-system 'utf-8))
  #+end_src
  
 
* Convert buffer from DOS end-of-lines to Unix end-of-lines and vice versa
  #+begin_src emacs-lisp
    (defun dos-to-unix ()
      "Cut all visible ^M from the current buffer."
      (interactive)
      (save-excursion
        (goto-char (point-min))
        (while (search-forward "\r" nil t)
          (replace-match ""))))
    
    (defun unix-to-dos ()
      (interactive)
      (save-excursion
        (goto-char (point-min))
        (while (search-forward "\n" nil t)
          (replace-match "\r\n"))))
  #+end_src


* RE Builder configurations
  #+begin_src emacs-lisp
    (require 're-builder)
    (setq reb-re-syntax 'string)
  #+end_src


* Save minibuffer history across sessions
  #+begin_src emacs-lisp
    (savehist-mode 1)
  #+end_src
 

* Create unique names for same named buffers
  #+begin_src emacs-lisp
    (load "uniquify")
    (setq uniquify-buffer-name-style 'post-forward)
  #+end_src


* Auto refresh buffers
  #+begin_src emacs-lisp
    (global-auto-revert-mode 1)
  #+end_src
  

* Use ibuffer instead of regular buffer switcher
  #+begin_src emacs-lisp
    (global-set-key (kbd "C-x C-b") 'ibuffer)
  #+end_src


* Backup walker traverses versioned backups, showing incremental diffs

  #+begin_src emacs-lisp
    (el-get 'sync 'backup-walker)
    (require 'backup-walker)
  #+end_src
  

* Wgrep allows modifying the grep buffer and apply the changes to the files

  #+begin_src emacs-lisp
    (el-get 'sync 'emacs-wgrep)
    (load "wgrep")
  #+end_src


* Replace words in parallel taken from [[http://stackoverflow.com/questions/2588277/how-can-i-swap-or-replace-multiple-strings-in-code-at-the-same-time][stackoverflow]]

  #+begin_src emacs-lisp 
    (require 'cl)
    (defun parallel-query-replace (plist &optional delimited start end)
      "Replace every occurrence of the (2n)th token of PLIST in
    buffer with the (2n+1)th token; if only two tokens are provided,
    replace them with each other (ie, swap them).
    
    If optional second argument DELIMITED is nil, match words
    according to syntax-table; otherwise match symbols.
    
    When called interactively, PLIST is input as space separated
    tokens, and DELIMITED as prefix arg."
      (interactive
       `(,(loop with input = (read-from-minibuffer "Replace: ")
                with limit = (length input)
                for  j = 0 then i
                for (item . i) = (read-from-string input j)
                collect (prin1-to-string item t) until (<= limit i))
         ,current-prefix-arg
         ,@(if (use-region-p) `(,(region-beginning) ,(region-end)))))
      (let* ((alist (cond ((= (length plist) 2) (list plist (reverse plist)))
                          ((loop for (key val . tail) on plist by #'cddr
                                 collect (list (prin1-to-string key t) val)))))
             (matcher (regexp-opt (mapcar #'car alist)
                                  (if delimited 'words 'symbols)))
             (to-spec `(replace-eval-replacement replace-quote
                                                 (cadr (assoc-string (match-string 0) ',alist
                                                                     case-fold-search)))))
        (query-replace-regexp matcher to-spec nil start end)))
  #+end_src
  

* Seamlessly create, edit, remove boxes
  
  #+begin_src emacs-lisp
    (el-get 'sync 'rebox2)
    (setq rebox-style-loop '(24 16))
    (require 'rebox2)
    (global-set-key (kbd "C-c q") 'rebox-dwim)
    (global-set-key (kbd "C-c Q") 'rebox-cycle)
  #+end_src
  
