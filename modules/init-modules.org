* Code to speed up the loading of modules
  Loading all of the config files at the startup is expensive since 
  each file first converted from .org to .el files and then loaded 
  separately to overcome this we do the following 
  1) Convert the org mode files to el files 
  2) Combine their code in one file and load it
  
  Now at subsequent emacs startups we first check if any org
  file is newer then the compiled file, if so repeat step 1) and 2)
  This way the startup will be slow only when any of the org files
  are modified or there is some new org file, otherwise it will be
  faster since we load a single file
  #+begin_src emacs-lisp    
    (defvar iqbal-modules-dir "~/.emacs.d/modules/")
    
    (defvar iqbal-modules-compiled-dir (concat "~/.emacs.d/modules/" ".compiled/"))
    
    (defvar iqbal-tangled-modules (concat iqbal-modules-compiled-dir ".combined.el"))
    
    (defvar iqbal-previous-modules-file (concat iqbal-modules-compiled-dir ".previous-modules"))
    (defvar iqbal-previous-modules nil "Will be loaded from `iqbal-previous-modules-file'")
    
    (unless (file-exists-p (concat iqbal-modules-dir "/.compiled/"))
      (make-directory (concat iqbal-modules-dir "/.compiled/")))
    
    (defun iqbal-get-file-mod-time (path)
      (nth 5 (file-attributes path)))
    
    (defun iqbal-get-module-paths (suffix &optional dir)
      (map 'list 
           (lambda (module) 
             (concat iqbal-modules-dir 
                     (or (concat dir "/") "")
                     "init-" (symbol-name module) suffix))
           iqbal-modules-list))
    
    (defun iqbal-get-org-module-paths ()
      (iqbal-get-module-paths ".org"))
    
    (defun iqbal-get-el-module-paths ()
      (iqbal-get-module-paths ".el" ".compiled"))
    
    (defun iqbal-get-module-org-file (module)
      (concat iqbal-modules-dir "init-" (symbol-name module) ".org"))
    
    (defun iqbal-get-module-el-file (module)
      (concat iqbal-modules-dir ".compiled/" "init-" (symbol-name module) ".el"))
    
    (defun iqbal-module-file-newer? (module)
      (let ((module-file-mod-time (iqbal-get-file-mod-time (iqbal-get-module-org-file module)))
            (modules-compiled-time (iqbal-get-file-mod-time iqbal-tangled-modules)))
        (or (not (file-exists-p (iqbal-get-module-el-file module)))
            (> (nth 0 module-file-mod-time) (nth 0 modules-compiled-time))
            (and (= (nth 0 module-file-mod-time) (nth 0 modules-compiled-time))
                 (> (nth 1 module-file-mod-time) (nth 1 modules-compiled-time))))))
    
    (defun iqbal-get-newer-modules ()
      (remove-if-not (lambda (module-file)
                       (iqbal-module-file-newer? module-file))
                     iqbal-modules-list))
        
    (defun iqbal-compile-modules (modules)
      "Tangle the MODULES and concat store the combined results in
    a single file also write the current modules to .previous-modules
    This file is read to determine if any module has been removed
    since last compilation
    "
      (interactive (list (iqbal-get-newer-modules)))
      (dolist (module modules)
        (org-babel-tangle-file (iqbal-get-module-org-file module)
                               (iqbal-get-module-el-file module)
                               "emacs-lisp"))
      (let ((extracted-code (reduce #'(lambda (code input-file)
                                        (concat code (iqbal-read-file input-file)))
                                    (iqbal-get-el-module-paths) :initial-value "")))
        (with-temp-file iqbal-tangled-modules
          (insert extracted-code))
        (byte-compile-file iqbal-tangled-modules)
        (with-temp-file iqbal-previous-modules-file
          (insert (concat "(setq iqbal-previous-modules '"
                          (prin1-to-string iqbal-modules-list)
                          ")")))))
    
    (defun iqbal-modules-changed?()
      "Check if any module has been removed"
      (when (file-exists-p iqbal-previous-modules-file)
        (load-file iqbal-previous-modules-file)
        ;; If the meta file does not exist, iqbal-previous-modules
        ;; will be nil
        (not (equal iqbal-modules-list iqbal-previous-modules))))
    
    (defun iqbal-compile-and-load-modules ()
      "If any new module(s) are added or any module has been
    removed, then compile and load compiled file
    or simply load previously compiled file
    "
      (interactive)
      (let ((newer-modules (iqbal-get-newer-modules)))
        (when (or newer-modules (iqbal-modules-changed?))
          (iqbal-compile-modules newer-modules))
        (load-file iqbal-tangled-modules)))
    
    (defun iqbal-remove-generated-files ()
      (let* ((language-related-gen (mapcar (lambda (dir)
                                             (concat dir "/.compiled"))
                                           (remove-if-not #'file-directory-p
                                                          (directory-files iqbal-langs-dir t "[^.]+")))))
        (delete-directory (concat iqbal-modules-dir "/.compiled/") t nil)
    
        (dolist (gen-file language-related-gen)
          (when (file-exists-p gen-file)
            (delete-file gen-file)))))
  #+end_src


* List of modules to be loaded
  #+begin_src emacs-lisp
    (defvar iqbal-modules-list '(display auto-complete backup files buffers dired editing
                                         navigation search-replace ido parenthesis syntax-check 
                                         shell org utilities version-control yasnippet project
                                         window-management mail))
  #+end_src

  
* Load the modules
  #+begin_src emacs-lisp
    (iqbal-compile-and-load-modules)
  #+end_src
  
