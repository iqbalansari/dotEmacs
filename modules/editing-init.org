* Install some useful packages
+ [[https://github.com/winterTTr/ace-jump-mode/wiki][ace-jump-mode]] Move your cursor to ANY position in visible region quickly
+ [[http://www.dr-qubit.org/undo-tree/undo-tree-0.6.4.el][undo-tree]] - Represents your undo history as a tree and provides some really useful features
+ [[https://github.com/browse-kill-ring/browse-kill-ring][browse-kill-ring]] - Useful package for interacting with the kill ring visually
+ [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]] - Multiple cursors for emacs.
+ [[https://github.com/abo-abo/tiny][tiny]] - Quickly generate linear ranges in Emacs
+ [[https://github.com/magnars/expand-region.el][expand-region]] - Emacs extension to increase selected region by semantic units.
+ [[https://github.com/nflath/hungry-delete][hungry-delete]] - Get hungry delete everywhere

#+begin_src emacs-lisp
  (defvar iqbal-editing-packages
    '(undo-tree
      browse-kill-ring
      multiple-cursors
      tiny
      expand-region
      hungry-delete))
  
  (el-get 'sync iqbal-editing-packages)  
#+end_src   


* Replace selected region with typed text
  #+begin_src emacs-lisp
    (delete-selection-mode)
  #+end_src


* Multiple cursors setup
  Keybindings for multiple cursors
  #+begin_src emacs-lisp
    (global-set-key (kbd "C-S-m") 'mc/mark-more-like-this-extended)
    (global-set-key (kbd "C-S-l") 'mc/edit-lines)
    (global-set-key (kbd "C-S-c") 'mc/mark-all-like-this-dwim)
    (global-set-key (kbd "C-S-<mouse-1>") 'mc/add-cursor-on-click)
    (global-set-key (kbd "C-S-r") 'set-rectangular-region-anchor)
  #+end_src
  

* Tiny setup
  Keybindings for expanding tiny expressions
  #+begin_src emacs-lisp
    (load "tiny")
    (global-set-key (kbd "C-:") 'tiny-expand)
  #+end_src
  
       	       	   
* Expand region setup
  #+begin_src emacs-lisp
    (global-set-key (kbd "C-=") 'er/expand-region)
    (global-set-key (kbd "C--") 'er/contract-region)
  #+end_src
  

* Prompt for user input during macro execution
  Following was borrowed from [[http://www.emacswiki.org/emacs/KeyboardMacros#toc5][emacswiki]], Pressing ‘C-x Q’ during macro
  definition will present you with a minibuffer prompt (using
  recursive edit). Inserting some text and pressing RET will end
  recursive edit and continue the definition of the macro in the
  minibuffer. Pressing RET again will insert the entered text at
  point. If you don’t want to insert the text right away you can
  instead kill the input at this point (using ‘C-a C-k RET’) and use
  it later in the macro definition.
  #+begin_src emacs-lisp
    (defun my-macro-query (arg)
      "Prompt for input using minibuffer during kbd macro execution.
        With prefix argument, allows you to select what prompt string to use.
        If the input is non-empty, it is inserted at point."
      (interactive "P")
      (let* ((prompt (if arg (read-from-minibuffer "PROMPT: ") "Input: "))
             (input (minibuffer-with-setup-hook (lambda () (kbd-macro-query t))
                      (read-from-minibuffer prompt))))
        (unless (string= "" input) (insert input))))
    (global-set-key "\C-xQ" 'my-macro-query)
  #+end_src
  

* Undo tree setup
** Keep the region active when undoing in a region
   #+begin_src emacs-lisp
     (defadvice undo-tree-undo (around keep-region activate)
       (if (use-region-p)
           (let ((m (set-marker (make-marker) (mark)))
                 (p (set-marker (make-marker) (point))))
             ad-do-it
             (goto-char p)
             (set-mark m)
             (set-marker p nil)
             (set-marker m nil))
         ad-do-it))
   #+end_src

** Enable undo-tree globally
  #+begin_src emacs-lisp
    (global-undo-tree-mode)
  #+end_src
  

* Browse kill ring setup
** Use default keybindings
  #+begin_src emacs-lisp
    (browse-kill-ring-default-keybindings)
    (global-set-key (kbd "M-y") 'browse-kill-ring)
  #+end_src
  
** Don't highlight current candidate in kill-ring
   #+begin_src emacs-lisp
     (setq browse-kill-ring-highlight-inserted-item nil)
   #+end_src
   

* Toggle comment region or line if no region is selected
  #+begin_src emacs-lisp
    (defun comment-or-uncomment-region-or-line ()
        "Comments or uncomments the region or the current line if there's no active region."
        (interactive)
        (let (beg end)
            (if (region-active-p)
                (setq beg (region-beginning) end (region-end))
                (setq beg (line-beginning-position) end (line-end-position)))
            (comment-or-uncomment-region beg end)
            (next-line)))
    (global-set-key (kbd "M-;") 'comment-or-uncomment-region-or-line)
  #+end_src


* Show all lines matching REGEXP in buffers with this major mode. Taken from
  [[http://www.masteringemacs.org/articles/2011/07/20/searching-buffers-occur-mode/][mastering-emacs]]
  #+begin_src emacs-lisp
    (eval-when-compile
      (require 'cl))
    
    ;; Get lines matching REGEXP in all buffers with this major mode
    (defun get-buffers-matching-mode (mode)
      "Returns a list of buffers where their major-mode is equal to MODE"
      (let ((buffer-mode-matches '()))
        (dolist (buf (buffer-list))
          (with-current-buffer buf
            (if (eq mode major-mode)
                (add-to-list 'buffer-mode-matches buf))))
        buffer-mode-matches))
    
    (defun multi-occur-in-this-mode ()
      "Show all lines matching REGEXP in buffers with this major mode."
      (interactive)
      (multi-occur
       (get-buffers-matching-mode major-mode)
       (car (occur-read-primary-args))))
    
    (global-set-key (kbd "M-o") 'multi-occur-in-this-mode)
  #+end_src


* Keybindings to highlight text according to regexp
  #+begin_src emacs-lisp
    (global-set-key (kbd "C-c h l") 'highlight-lines-matching-regexp)
    (global-set-key (kbd "C-c h w") 'highlight-regexp)
    (global-set-key (kbd "C-c h r") 'unhighlight-regexp)
  #+end_src


* Copy/cut current line if no region is selected
  #+begin_src emacs-lisp
    ;; (defun copy-line-or-region ()
    ;;   "Copy current line, or current text selection."
    ;;   (interactive)
    ;;   (if (region-active-p)
    ;;       (kill-ring-save (region-beginning) (region-end))
    ;;     (kill-ring-save (line-beginning-position) (line-beginning-position 2)) ) )
    
    ;; (defun cut-line-or-region ()
    ;;   "Cut the current line, or current text selection."
    ;;   (interactive)
    ;;   (if (region-active-p)
    ;;       (kill-region (region-beginning) (region-end))
    ;;     (kill-region (line-beginning-position) (line-beginning-position 2)) ) )
    
    ;; (global-set-key (kbd "M-w") 'copy-line-or-region)
    ;; (global-set-key (kbd "C-w") 'cut-line-or-region)
  #+end_src


* Keybinding to join lines
  #+begin_src emacs-lisp
    (global-set-key (kbd "M-j")
            (lambda ()
                  (interactive)
                  (join-line -1)))
  #+end_src


* Keybindings to move quickly
  Move by then units by using ctrl + shift + [npfb]
  #+begin_src emacs-lisp
    (global-set-key (kbd "C-S-n")
                    (lambda ()
                      (interactive)
                      (ignore-errors (next-line 10))))
    
    (global-set-key (kbd "C-S-p")
                    (lambda ()
                      (interactive)
                      (ignore-errors (previous-line 10))))
    
    (global-set-key (kbd "C-S-f")
                    (lambda ()
                      (interactive)
                      (ignore-errors (forward-char 10))))
    
    (global-set-key (kbd "C-S-b")
                    (lambda ()
                      (interactive)
                      (ignore-errors (backward-char 10))))
    
  #+end_src
  
  

* Keybinding for duplicate current line or region
  Duplicate current line if region is not selected else duplicate the region
  taken from [[http://stackoverflow.com/questions/88399/how-do-i-duplicate-a-whole-line-in-emacs][stackoverflow]].
  #+begin_src emacs-lisp
    (defun duplicate-line-or-region (&optional n)
      "Duplicate current line, or region if active.
    With argument N, make N copies.
    With negative N, comment out original line and use the absolute value."
      (interactive "*p")
      (let ((use-region (use-region-p)))
        (save-excursion
          (let ((text (if use-region        ;Get region if active, otherwise line
                          (buffer-substring (region-beginning) (region-end))
                        (prog1 (thing-at-point 'line)
                          (end-of-line)
                          (if (< 0 (forward-line 1)) ;Go to beginning of next line, or make a new one
                              (newline))))))
            (dotimes (i (abs (or n 1)))     ;Insert N times, or once if not specified
              (insert text))))
        (if use-region nil                  ;Only if we're working with a line (not a region)
          (let ((pos (- (point) (line-beginning-position)))) ;Save column
            (if (> 0 n)                             ;Comment out original with negative arg
                (comment-region (line-beginning-position) (line-end-position)))
            (forward-line 1)
            (forward-char pos)))))
    
    (global-set-key (kbd "C-x C-d") 'duplicate-line-or-region)
  #+end_src
  

* Convenient functions for opening newlines
  Typing shift + return anywhere on a line will create a new line below the current
  line, ctrl + shift + return will open a line above
  #+begin_src emacs-lisp
    (defun open-line-below ()
      (interactive)
      (end-of-line)
      (newline)
      (indent-for-tab-command))
    
    (defun open-line-above ()
      (interactive)
      (beginning-of-line)
      (newline)
      (forward-line -1)
      (indent-for-tab-command))
    
    (global-set-key (kbd "<S-return>") 'open-line-below)
    (global-set-key (kbd "<C-S-return>") 'open-line-above)
  #+end_src
  

* Echo matching paren when it is offscreen
  #+begin_src emacs-lisp
    (defadvice show-paren-function
        (after show-matching-paren-offscreen activate)
      "If the matching paren is offscreen, show the matching line in the
          echo area. Has no effect if the character before point is not of
          the syntax class ')'."
      (interactive)
      (let* ((cb (char-before (point)))
             (matching-text (and cb
                                 (char-equal (char-syntax cb) ?\) )
                                 (blink-matching-open))))
        (when matching-text (message matching-text))))
  #+end_src


* Kill line backwards
  #+begin_src emacs-lisp
    (defun backward-kill-line (arg)
      "Kill ARG lines backward."
      (interactive "p")
      (kill-line (- 1 arg)))
    
    (global-set-key (kbd "C-S-k") 'backward-kill-line)
  #+end_src
  

* Use regex searches by default.
  #+begin_src emacs-lisp
    (global-set-key (kbd "C-s") 'isearch-forward-regexp)
    (global-set-key (kbd "\C-r") 'isearch-backward-regexp)
    (global-set-key (kbd "C-M-s") 'isearch-forward)
    (global-set-key (kbd "C-M-r") 'isearch-backward)
  #+end_src


* Functions to increment and decrement integers at point
  These were borrowed from prelude
  #+begin_src emacs-lisp
    (require 'thingatpt)
    
    (defun thing-at-point-goto-end-of-integer ()
      "Go to end of integer at point."
      (let ((inhibit-changing-match-data t))
        ;; Skip over optional sign
        (when (looking-at "[+-]")
          (forward-char 1))
        ;; Skip over digits
        (skip-chars-forward "[[:digit:]]")
        ;; Check for at least one digit
        (unless (looking-back "[[:digit:]]")
          (error "No integer here"))))
    (put 'integer 'beginning-op 'thing-at-point-goto-end-of-integer)
    
    (defun thing-at-point-goto-beginning-of-integer ()
      "Go to end of integer at point."
      (let ((inhibit-changing-match-data t))
        ;; Skip backward over digits
        (skip-chars-backward "[[:digit:]]")
        ;; Check for digits and optional sign
        (unless (looking-at "[+-]?[[:digit:]]")
          (error "No integer here"))
        ;; Skip backward over optional sign
        (when (looking-back "[+-]")
          (backward-char 1))))
    (put 'integer 'beginning-op 'thing-at-point-goto-beginning-of-integer)
    
    (defun thing-at-point-bounds-of-integer-at-point ()
      "Get boundaries of integer at point."
      (save-excursion
        (let (beg end)
          (thing-at-point-goto-beginning-of-integer)
          (setq beg (point))
          (thing-at-point-goto-end-of-integer)
          (setq end (point))
          (cons beg end))))
    (put 'integer 'bounds-of-thing-at-point 'thing-at-point-bounds-of-integer-at-point)
    
    (defun thing-at-point-integer-at-point ()
      "Get integer at point."
      (let ((bounds (bounds-of-thing-at-point 'integer)))
        (string-to-number (buffer-substring (car bounds) (cdr bounds)))))
    (put 'integer 'thing-at-point 'thing-at-point-integer-at-point)
    
    (defun increment-integer-at-point (&optional inc)
      "Increment integer at point by one.
    
    With numeric prefix arg INC, increment the integer by INC amount."
      (interactive "p")
      (let ((inc (or inc 1))
            (n (thing-at-point 'integer))
            (bounds (bounds-of-thing-at-point 'integer)))
        (delete-region (car bounds) (cdr bounds))
        (insert (int-to-string (+ n inc)))))
    
    (defun decrement-integer-at-point (&optional dec)
      "Decrement integer at point by one.
    
    With numeric prefix arg DEC, decrement the integer by DEC amount."
      (interactive "p")
      (increment-integer-at-point (- (or dec 1))))
    
    (global-set-key (kbd "C-c +") 'increment-integer-at-point)
    (global-set-key (kbd "C-c -") 'decrement-integer-at-point)
  #+end_src


* Keybindings for navigating between errors
  #+begin_src emacs-lisp
    (global-set-key (kbd "M-n") 'next-error)
    (global-set-key (kbd "M-p") 'previous-error)
  #+end_src


* Auto-indent on yanked text taken from [[http://www.emacswiki.org/emacs/AutoIndentation#toc3][emacswiki]]
  #+begin_src emacs-lisp
    (dolist (command '(yank yank-pop))
       (eval `(defadvice ,command (after indent-region activate)
                (and (not current-prefix-arg)
                     (member major-mode '(emacs-lisp-mode lisp-mode
                                                          clojure-mode    scheme-mode
                                                          haskell-mode    ruby-mode
                                                          rspec-mode      python-mode
                                                          c-mode          c++-mode
                                                          objc-mode       latex-mode
                                                          plain-tex-mode))
                     (let ((mark-even-if-inactive transient-mark-mode))
                       (indent-region (region-beginning) (region-end) nil))))))
  #+end_src


* Keybindings for hungry deletion
  #+begin_src emacs-lisp
    (require 'hungry-delete)
    (global-set-key (kbd "C-c DEL") 'hungry-delete-backward)
    (global-set-key (kbd "C-c <deletechar>") 'hungry-delete-forward)
  #+end_src
  
