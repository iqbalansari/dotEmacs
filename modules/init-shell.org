* Install projectile if not installed yet
  #+begin_src emacs-lisp
    (el-get 'sync 'projectile)
  #+end_src


* Faster keybinding to switch between line and character mode in term
  #+begin_src emacs-lisp
    (defun my-toggle-term-mode ()
      (interactive)
      (if (term-in-line-mode)
          (progn (term-char-mode)
                 (message "Switched to char mode"))
        (term-line-mode)
        (message "Switched to line mode")))

    (eval-after-load "term"
      '(progn (define-key term-raw-map (kbd "C-`") 'my-toggle-term-mode)
              (define-key term-mode-map (kbd "C-`") 'my-toggle-term-mode)))
  #+end_src


* Set C-x as the prefix command rather than C-c
  #+begin_src emacs-lisp
    (eval-after-load 'term
      '(term-set-escape-char ?\C-x))
  #+end_src


* Set keybindings to yank and undo in the term
  #+begin_src emacs-lisp
    (eval-after-load 'term
      '(progn (define-key term-raw-map "\C-y" 'term-paste)
              (define-key term-raw-map (kbd "C-/") (lambda () (interactive) (term-send-raw-string (kbd "C-_"))))))
  #+end_src


* Fix C-<right>, C-<left> in term, don't know why it was not working in the first place
  #+begin_src emacs-lisp
    (eval-after-load 'term
      '(progn (define-key term-raw-map (kbd "C-<left>") (lambda ()
                                                          (interactive)
                                                          (term-send-raw-string (kbd "\033[1;5D"))))
              (define-key term-raw-map (kbd "C-<right>") (lambda ()
                                                           (interactive)
                                                           (term-send-raw-string (kbd "\033[1;5C"))))))
  #+end_src


* Keybinding to facilitate copying region in term-mode
** A simple function that executes the command bound to
   the key in global-map if region is active otherwise
   sends the last keys to the terminal emulator
  #+begin_src emacs-lisp
    (defun my-execute-command-if-region-or-send-raw (&optional meta?)
      (interactive)
      (let* ((keys (this-single-command-keys))
             (command (lookup-key global-map keys)))
        (cond ((and (region-active-p) command)
               (call-interactively command))
              (meta?  (term-send-raw-meta))
              (t (term-send-raw)))))

    (defun my-execute-command-if-region-or-send-raw-meta ()
      (interactive)
      (my-execute-command-if-region-or-send-raw t))
  #+end_src

** Capture C-n, C-p, C-a, C-e, M-< and M-> is region is active or send
   raw keys to the terminal
   #+begin_src emacs-lisp
     (eval-after-load 'term
       '(progn (define-key term-raw-map "\C-n" 'my-execute-command-if-region-or-send-raw)
               (define-key term-raw-map "\C-p" 'my-execute-command-if-region-or-send-raw)
               (define-key term-raw-map "\C-a" 'my-execute-command-if-region-or-send-raw)
               (define-key term-raw-map "\C-e" 'my-execute-command-if-region-or-send-raw)
               (define-key term-raw-map "\C-w" 'my-execute-command-if-region-or-send-raw)
               (define-key term-raw-map "\M-w" 'my-execute-command-if-region-or-send-raw-meta)
               (define-key term-raw-map "\M-<" 'my-execute-command-if-region-or-send-raw-meta)
               (define-key term-raw-map "\M->" 'my-execute-command-if-region-or-send-raw-meta)))
   #+end_src


* Making shift-tab work with term-mode
  #+begin_src emacs-lisp
    (defun my-term-send-backtab ()
      "Send backtab to the term process"
      (interactive)
      (term-send-raw-string (kbd "\033[Z")))

    (eval-after-load 'term
      '(define-key term-raw-map (kbd "<backtab>") 'my-term-send-backtab))
  #+end_src


* Yasnippet breaks tab completion in term-mode disable it
  #+begin_src emacs-lisp
    (add-hook 'term-mode-hook (lambda ()
                                (yas-minor-mode -1)
                                (toggle-truncate-lines 1)))
  #+end_src


* Disable hl-line-mode in term buffer
  Need to set hl-line-range-function function since (hl-line-mode -1)
  isn't working
  #+begin_src emacs-lisp
    (defun my-hide-hl-line ()
      (make-local-variable 'hl-line-range-function)
      (setq hl-line-range-function (lambda () nil)))

    (add-hook 'term-mode-hook #'my-hide-hl-line)
  #+end_src



* Better colors for term mode
  #+begin_src emacs-lisp
    (eval-after-load 'term
      '(progn (set-face-attribute 'term-color-blue nil :foreground "#1e90ff")
             (set-face-attribute 'term-color-red nil :foreground "#ee5c42")
             (set-face-attribute 'term-color-cyan nil :foreground "#8cd0d3")
             (set-face-attribute 'term-color-green nil :foreground "#00ff00")))
  #+end_src


* Convenience functions to start term buffers
** Definition of functions
  #+begin_src emacs-lisp
    (defvar my-preferred-shell (or (executable-find "zsh")
                                   (executable-find "bash")))

    (defvar my-shell-to-project-map (make-hash-table :test 'equal))

    (defun my-create-shell-buffer (&optional name)
      "Create a new shell, if my prefered shell is set
      start that shell otherwise start eshell, rename
      the shell using login name, system name and name
      if given"
      (let ((shell-name (concat (user-real-login-name) "@" (system-name)
                                (when name
                                  (concat " - " name)))))
        (if my-preferred-shell
            (ansi-term my-preferred-shell shell-name)
          (eshell)
          (rename-buffer shell-name t)
          (current-buffer))))

    (defun my-get-live-shell-for-project (project-root)
      "Return the first live shell for a project"
      ;; Clean up any killed shells
      (puthash project-root
               (remove-if-not (lambda (buffer)
                                (buffer-live-p buffer))
                              (gethash project-root my-shell-to-project-map))
               my-shell-to-project-map)

      ;; Return the first live shell
      (car (gethash project-root my-shell-to-project-map)))

    (defun my-create-new-shell-and-store (project-root)
      "Create a new shell for the project and store it in the global hash"
      (puthash project-root
               (cons (my-create-shell-buffer project-root)
                     (gethash project-root my-shell-to-project-map))
               my-shell-to-project-map))

    (defun my-open-shell-for-project (project-root &optional force?)
      "Open a shell for the project, switches to existing shell if
       there already exists a shell for the project and force? is nil
       otherwise create a new shell"
      (let ((shell (my-get-live-shell-for-project project-root)))
        (cond ((and shell (not force?))
               (message "Switching to existing shell")
               (switch-to-buffer (car (gethash project-root my-shell-to-project-map))))
              (force? (message "Creating new shell")
                      (my-create-new-shell-and-store project-root))
              (t (message "No associated shell found! Creating new shell")
                 (my-create-new-shell-and-store project-root)))))

    (defun my-start-shell (&optional force?)
      (my-open-shell-for-project (or (ignore-errors (projectile-project-root)) "global") force?))

    (defun my-split-window-below-start-terminal ()
      (interactive)
      (select-window (split-window-below))
      (my-start-shell (or current-prefix-arg
                          (eq major-mode 'term-mode)
                          (eq major-mode 'eshell))))

    (defun my-split-window-right-start-terminal ()
      (interactive)
      (select-window (split-window-right))
      (my-start-shell (or current-prefix-arg
                          (eq major-mode 'term-mode)
                          (eq major-mode 'eshell))))

    (defun my-start-terminal ()
      (interactive)
      (my-start-shell (or current-prefix-arg
                          (eq major-mode 'term-mode)
                          (eq major-mode 'eshell))))

    (defun my-kill-term-buffer ()
      (let ((kill-buffer-query-functions nil)
            (number-of-windows (length (window-list))))
        (kill-buffer)
        (unless (equal number-of-windows 1)
          (delete-window))))

    (defun my-kill-term-delete-window ()
      (interactive)
      (if (or (eq major-mode 'term-mode)
              (eq major-mode 'eshell-mode))
          (my-kill-term-buffer)
        (message "Not in a shell")))
  #+end_src

** Keybindings
   #+begin_src emacs-lisp
     (global-set-key (kbd "C-\\") 'my-split-window-below-start-terminal)
     (global-set-key (kbd "C-|") 'my-split-window-right-start-terminal)
     (global-set-key (kbd "C-S-w") 'my-kill-term-delete-window)
     (global-set-key (kbd "C-S-t") 'my-start-terminal)
     (eval-after-load "term"
       '(define-key term-raw-map (kbd "C-\\") 'my-split-window-below-start-terminal))
   #+end_src


* Various customizations picked up from [[http://snarfed.org/why_i_run_shells_inside_emacs][snarfed.org]]
** Always add output at the bottom
   #+begin_src emacs-lisp
     (setq comint-scroll-to-bottom-on-output nil)
   #+end_src

** No duplicates in command history
   #+begin_src emacs-lisp
     (setq comint-input-ignoredups t)
   #+end_src

** Truncate buffers continuously
   #+begin_src emacs-lisp
     (add-hook 'comint-output-filter-functions 'comint-truncate-buffer)
   #+end_src

** Set pager to 'cat'
   #+begin_src emacs-lisp
     (setenv "PAGER" "cat")
   #+end_src

** Scroll conservatively in shells
   #+begin_src emacs-lisp
     (defun set-scroll-conservatively ()
       "Add to shell-mode-hook to prevent jump-scrolling on newlines in shell buffers."
       (set (make-local-variable 'scroll-conservatively) 10))

     (add-hook 'shell-mode-hook 'set-scroll-conservatively)
   #+end_src


* Few useful tips from wikiemacs
** Make URLs clickable
   #+begin_src emacs-lisp
     (add-hook 'shell-mode-hook 'goto-address-mode)
     (add-hook 'term-mode-hook 'goto-address-mode)
   #+end_src
