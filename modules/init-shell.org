* Faster keybinding to switch between line and character mode in term
  #+begin_src emacs-lisp
    (defun my-toggle-term-mode ()
      (interactive)
      (if (term-in-line-mode)
          (progn (term-char-mode)
                 (message "Switched to char mode"))
        (term-line-mode)
        (message "Switched to line mode")))
    
    (eval-after-load "term"
      '(progn (define-key term-raw-map (kbd "C-`") 'my-toggle-term-mode)
              (define-key term-mode-map (kbd "C-`") 'my-toggle-term-mode)))
  #+end_src


* Set C-x as the prefix command rather than C-c
  #+begin_src emacs-lisp
    (eval-after-load 'term
      '(term-set-escape-char ?\C-x))
  #+end_src


* Set keybindings to copy and yank in the term
  #+begin_src emacs-lisp
    (eval-after-load 'term
      '(progn (define-key term-raw-map "\C-y" 'term-paste)
              (define-key term-raw-map "\M-w" 'copy-line-or-region)
              (define-key term-raw-map "\C-w" 'cut-line-or-region)))
  #+end_src


* Keybinding to facilitate copying region in term-mode
** A simple function that executes the command bound to
   the key in global-map if region is active otherwise
   sends the last keys to the terminal emulator
  #+begin_src emacs-lisp
    (defun my-execute-command-or-send-raw (&optional meta?)
      (interactive)
      (let* ((keys (this-single-command-keys))
             (command (lookup-key global-map keys)))
        (cond ((and (region-active-p) command)
               (call-interactively command))
              (meta?  (term-send-raw-meta))
              (t (term-send-raw)))))
    
    (defun my-execute-command-or-send-raw-meta ()
      (interactive)
      (my-execute-command-or-send-raw t))
  #+end_src

** Capture C-n, C-p, C-a, C-e, M-< and M-> is region is active or send
   raw keys to the terminal
   #+begin_src emacs-lisp
     (eval-after-load 'term
       '(progn (define-key term-raw-map "\C-n" 'my-execute-command-or-send-raw)
               (define-key term-raw-map "\C-p" 'my-execute-command-or-send-raw)
               (define-key term-raw-map "\C-a" 'my-execute-command-or-send-raw)
               (define-key term-raw-map "\C-e" 'my-execute-command-or-send-raw)
               (define-key term-raw-map "\M-<" 'my-execute-command-or-send-raw-meta)
               (define-key term-raw-map "\M->" 'my-execute-command-or-send-raw-meta)))
   #+end_src


* Do not scroll term-buffers on output
  #+begin_src emacs-lisp
    (setq term-scroll-to-bottom-on-output nil)
  #+end_src


* Yasnippet breaks tab completion in term-mode disable it, also disable hl-line-mode
  #+begin_src emacs-lisp
    (add-hook 'term-mode-hook (lambda () 
                                (yas-minor-mode -1)
                                (hl-line-mode -1)))
  #+end_src


* Better colors for term mode
  #+begin_src emacs-lisp
    (set-face-attribute 'term-color-blue nil :foreground "#4169e1")
    (set-face-attribute 'term-color-red nil :foreground "#ff6347")
    (set-face-attribute 'term-color-cyan nil :foreground "#8cd0d3")
    (set-face-attribute 'term-color-green nil :foreground "#7cfc00")
  #+end_src


* Convenience functions to start term buffers
** Declaration of functions
  #+begin_src emacs-lisp
    (defvar my-preferred-shell (or (executable-find "zsh")
                                   (executable-find "bash")))
    
    (defun my-start-preferred-shell ()
      (if my-preferred-shell
          (ansi-term my-preferred-shell)
        (eshell))
      (rename-buffer (concat (user-real-login-name) "@" (system-name)) t))
    
    (defun my-split-window-below-start-terminal ()
      (interactive)
      (select-window (split-window-below))
      (my-start-preferred-shell))
    
    (defun my-split-window-right-start-terminal ()
      (interactive)
      (select-window (split-window-right))
      (my-start-preferred-shell))
    
    (defun my-kill-term-buffer ()
      (let ((kill-buffer-query-functions nil)
            (number-of-windows (length (window-list))))
        (kill-buffer)
        (unless (equal number-of-windows 1)
          (delete-window))))
    
    (defun my-kill-term-delete-window ()
      (interactive)
      (if (or (eq major-mode 'term-mode)
              (eq major-mode 'eshell-mode))
          (my-kill-term-buffer)
        (message "Not in a shell")))
  #+end_src

** Keybindings 
   #+begin_src emacs-lisp
     (global-set-key (kbd "C-S-e") 'my-split-window-below-start-terminal)
     (global-set-key (kbd "C-S-o") 'my-split-window-right-start-terminal)
     (global-set-key (kbd "C-S-w") 'my-kill-term-delete-window)
   #+end_src



* Various customizations picked up from [[http://snarfed.org/why_i_run_shells_inside_emacs][snarfed.org]]
** Always add output at the bottom
   #+begin_src emacs-lisp
     (setq comint-scroll-to-bottom-on-output nil)
   #+end_src

** No duplicates in command history
   #+begin_src emacs-lisp
     (setq comint-input-ignoredups t)
   #+end_src

** Truncate buffers continuously
   #+begin_src emacs-lisp
     (add-hook 'comint-output-filter-functions 'comint-truncate-buffer)
   #+end_src

** Set pager to 'cat'
   #+begin_src emacs-lisp
     (setenv "PAGER" "cat")
   #+end_src

** Scroll conservatively in shells
   #+begin_src emacs-lisp
     (defun set-scroll-conservatively ()
       "Add to shell-mode-hook to prevent jump-scrolling on newlines in shell buffers."
       (set (make-local-variable 'scroll-conservatively) 10))

     (add-hook 'shell-mode-hook 'set-scroll-conservatively)
   #+end_src


* Few useful tips from wikiemacs
** Make URLs clickable
   #+begin_src emacs-lisp
     (add-hook 'shell-mode-hook 'goto-address-mode)
     (add-hook 'term-mode-hook 'goto-address-mode)
   #+end_src

