* Install org-projectile, org-magit and org-journal
  #+begin_src emacs-lisp
    (my-install-packages '(org-projectile org-journal org-magit))
  #+end_src


* Directory for org-journal
  #+begin_src emacs-lisp
    (setq org-journal-dir (locate-user-emacs-file "org/journal/"))
  #+end_src


* Configuration for taking notes
** Install deft for managing notes
  #+begin_src emacs-lisp
    (my-install-package 'deft)
  #+end_src

** Path to notes directory
  #+begin_src emacs-lisp
    (defvar my-notes-dir (locate-user-emacs-file "org/notes/"))

    (unless (file-exists-p my-notes-dir)
      (make-directory my-notes-dir t))
  #+end_src

** Use org mode files for taking notes
   #+begin_src emacs-lisp
     (setq deft-extension "org")    
     (setq deft-text-mode 'org-mode)
   #+end_src

** Directory for notes folder
  #+begin_src emacs-lisp
    (setq deft-directory my-notes-dir)
  #+end_src

** Use filename as title in deft
   #+begin_src emacs-lisp
     (setq deft-use-filename-as-title t)
   #+end_src


* Configurations for emacs diary
** Store diary file in org folder
  #+begin_src emacs-lisp
    (setq diary-file (locate-user-emacs-file "org/diary"))
  #+end_src

** Let diary entries be included in agenda buffer
  #+begin_src emacs-lisp
    (setq org-agenda-include-diary t)
  #+end_src


* Enable notifications for appointments
** Do not show diary on initial appt setup
   #+begin_src emacs-lisp
     (setq appt-display-diary nil)
   #+end_src

** Warn 15 min in advance
  #+begin_src emacs-lisp
    (setq appt-message-warning-time 15)
  #+end_src

** Show remaining time in the modeline
   #+begin_src emacs-lisp
     (setq appt-display-mode-line t)
   #+end_src

** Show notification in a separate window
   #+begin_src emacs-lisp
     (setq appt-display-format 'window)
   #+end_src

** Enable appt and activate appointments found in org-agenda files
   #+begin_src emacs-lisp
     (defun my-appt-activate ()
       "(Re)initialize appt, also add agenda items to appt"
       (interactive)
       (setq appt-time-msg-list nil)
       (appt-activate +1)
       (org-agenda-to-appt))

     (add-hook 'after-init-hook #'my-appt-activate)

     (display-time)
   #+end_src

** Reinitialize appt on finishing capture and displaying agenda
   #+begin_src emacs-lisp
     (add-hook 'org-capture-after-finalize-hook #'my-appt-activate)
     (add-hook 'org-agenda-finalize-hook #'my-appt-activate)
   #+end_src

** Refresh appt at midnights
   #+begin_src emacs-lisp
     (run-at-time "24:01" nil #'my-appt-activate)
   #+end_src


* Configurations for org-agenda
** Enable org-habits
   #+begin_src emacs-lisp
     (load "org-habit")
   #+end_src

** Path to default org-captured file
  #+begin_src emacs-lisp
    (setq org-default-notes-file (concat my-notes-dir "/captured.org"))
  #+end_src

** The org agenda files
*** Org agenda files will stored in ~/.emacs.d/org/agenda/
   #+begin_src emacs-lisp
     (defvar my-org-agenda-dir (locate-user-emacs-file "org/agenda/"))

     (unless (file-exists-p my-org-agenda-dir)
       (make-directory my-org-agenda-dir t))
   #+end_src

*** Path to org-projectile todo file
   #+begin_src emacs-lisp
     (setq org-projectile:projects-file
           (concat my-org-agenda-dir "projects.org"))
   #+end_src

*** Any files in org folder will be added to agenda files
  #+begin_src emacs-lisp
    (setq org-agenda-files (list my-org-agenda-dir))
  #+end_src

** Add a note when task is marked as DONE
  #+begin_src emacs-lisp
    (setq org-log-done 'note)
  #+end_src

** `q` should bury agenda rather then killing it
   #+begin_src emacs-lisp
     (setq org-agenda-sticky t)
   #+end_src

** Ignore scheduled items or deadlines if they have been marked 'DONE'
   #+begin_src emacs-lisp
     (setq org-agenda-skip-deadline-if-done t)
     (setq org-agenda-skip-scheduled-if-done t)
   #+end_src

** Do not display tasks from past in org-agenda
   #+begin_src emacs-lisp
     (setq org-agenda-start-on-weekday nil)
   #+end_src


* Org capture templates
** Helper functions
*** Get url at point where org capture was called
    We need to switch to previous buffer since, the function is executed in
    context of org-capture buffer, not the buffer where org-capture was invoked
    #+begin_src emacs-lisp
      (defun my-get-url-at-point ()
        (require 'thingatpt)
        (save-window-excursion
          (switch-to-prev-buffer)
          (thing-at-point-url-at-point)))
    #+end_src

*** Get the url from the clipboard
   #+begin_src emacs-lisp
     (defun my-get-url-from-clipboard ()
       (require 'thingatpt)
       (let ((current-kill (ignore-errors (current-kill 0))))
         (when current-kill
           (with-temp-buffer
             (insert (string-trim current-kill))
             (goto-char 0)
             (thing-at-point-url-at-point)))))
   #+end_src

*** Get current url of w3m-buffer
    #+begin_src emacs-lisp
      (defun my-get-w3m-url ()
        (save-window-excursion
          (switch-to-prev-buffer)
          (when (equal major-mode 'w3m-mode)
            (or (get-text-property (point) 'w3m-href-anchor)
                w3m-current-url))))
    #+end_src

*** Get url from point or clipboard
    #+begin_src emacs-lisp
      (defun my-get-url-at-point-or-from-clipboard ()
        (require 'thingatpt)
        (or (my-get-url-at-point)
            (my-get-url-from-clipboard)
            (my-get-w3m-url)))
    #+end_src

*** Get name of major mode of buffer from which org-capture was called
    The returned value can be uses as language in '#+begin_src' markup. We need
    to switch to previous buffer since, the function is executed in context of
    org-capture buffer, not the buffer where org-capture was invoked
    #+begin_src emacs-lisp
      (defun my-get-source-buffers-mode ()
          (save-window-excursion
            (switch-to-prev-buffer)
            (substring (symbol-name major-mode) 0 -5)))
    #+end_src

*** Read date from user using calender widget and convert it to format diary can understand
    #+begin_src emacs-lisp
      (defun my--time-to-am/pm (hours minutes)
        (when (and hours minutes)
          (let* ((hours-int (string-to-int hours))
                 (hours-string (int-to-string (if (<= hours-int 12) 
                                                  hours-int
                                                (- hours-int 12))))
                 (suffix (if (< hours-int 12) 
                             "am"
                           "pm")))
            (concat hours-string ":" minutes suffix))))

      (defun my-read-date-for-diary ()
        (let* ((date-read (org-read-date))
               (date-components (split-string date-read))
               (date-string (split-string (car date-components) "-"))
               (time-components (when (cadr date-components)
                                  (split-string (cadr date-components) ":")))
               (hours (car time-components))
               (minutes (cadr time-components)))
          (concat (calendar-month-name (string-to-int (cadr date-string)))
                  " "
                  (caddr date-string)
                  ", "
                  (car date-string)
                  " "
                  (my--time-to-am/pm hours minutes))))
    #+end_src

*** Get the projectile project of the buffer from which capture was invoked
    #+begin_src emacs-lisp
      (defun my-get-source-buffers-project ()
        (save-window-excursion
          (switch-to-prev-buffer)
          (projectile-project-name)))
    #+end_src

*** Get active region in previous buffer as quote and org link to it
    #+begin_src emacs-lisp
      (defun my-justify-paragraph-text (text)
        (with-temp-buffer
          (insert text)
          (mark-whole-buffer)
          (fill-paragraph nil t)
          (buffer-string)))

      (defun my-indent-text (text &optional indent)
        (with-temp-buffer
          (insert text)
          (indent-region (point-min) (point-max) indent)
          (buffer-string)))

      (defun my-fix-newlines (text)
        (with-temp-buffer
          (insert (replace-regexp-in-string "\n"
                                            "\n\n"
                                            (replace-regexp-in-string "\\(\n\\)[^\n]" " " text nil nil 1)))
          (delete-trailing-whitespace)
          (buffer-string)))

      (defun my-get-source-buffers-region-and-link (&optional number)
        (save-window-excursion
          (dotimes (_ (or number 0)) (switch-to-prev-buffer))
          (switch-to-prev-buffer)
          (let ((fill-prefix "  "))
            (my-indent-text (concat (when (region-active-p)
                                      (concat "#+begin_quote\n"
                                              (my-indent-text (my-justify-paragraph-text (my-fix-newlines (buffer-substring (region-beginning)
                                                                                                                            (region-end))))
                                                              2)
                                              "\n#+end_quote\n"))
                                    (or (my-get-url-from-clipboard)
                                        (org-store-link nil)))
                            (when (region-active-p) 4 2)))))
    #+end_src

*** Function to get journal file
    #+begin_src emacs-lisp
      (defun my-find-journal-file ()
        (org-journal-dir-check-or-create)
        (let ((file-name (concat org-journal-dir
                                 (format-time-string org-journal-file-format))))
          (find-file file-name)
          (when (= 1 (point-max))
            (insert org-journal-date-prefix
                    (format-time-string org-journal-date-format)
                    "\n"))
          (goto-char (point-max))))
    #+end_src

** The templates
*** org-capture is not yet loaded, so initialize org-capture templates to empty list
    #+begin_src emacs-lisp
      (defvar org-capture-templates nil)
    #+end_src

*** Template for capturing todos
  #+begin_src emacs-lisp
    (add-to-list 'org-capture-templates (list "t"
                                              "TODO"
                                              'entry
                                              (list 'file
                                                    (locate-user-emacs-file "org/agenda/todos.org"))
                                              "* TODO %?\n%U\n\n"
                                              :empty-lines-after 2))
  #+end_src

*** Template for capturing todos linked to given buffer
  #+begin_src emacs-lisp
    (add-to-list 'org-capture-templates (list "T"
                                              "TODO linked to current buffer"
                                              'entry
                                              (list 'file
                                                    (locate-user-emacs-file "org/agenda/todos.org"))
                                              "* TODO %?\n%(my-get-source-buffers-region-and-link)\n%U\n\n"
                                              :empty-lines-after 2))
  #+end_src

*** Template for capturing links
    #+begin_src emacs-lisp
      (add-to-list 'org-capture-templates (list "l"
                                                "Interesting links"
                                                'entry
                                                (list 'file
                                                      (locate-user-emacs-file "org/notes/links.org"))
                                                "* UNREAD %?\n  %(my-get-url-at-point-or-from-clipboard) - Found on %U\n\n"
                                                :empty-lines-after 2))
    #+end_src

*** Template for capturing notes
    #+begin_src emacs-lisp
      (add-to-list 'org-capture-templates (list "n"
                                                "Note"
                                                'entry
                                                (list 'file
                                                      (locate-user-emacs-file "org/notes/notes.org"))
                                                "* %? %^G\n%U\n\n"
                                                :empty-lines-after 2))
    #+end_src

*** Template for capturing notes linked to a buffer
    #+begin_src emacs-lisp
      (add-to-list 'org-capture-templates (list "N"
                                                "Note"
                                                'entry
                                                (list 'file
                                                      (locate-user-emacs-file "org/notes/notes.org"))
                                                "* %? %^G\n%(my-get-source-buffers-region-and-link)\n%U\n\n"
                                                :empty-lines-after 2))
    #+end_src

*** Template for capturing code snippets
    #+begin_src emacs-lisp
      (add-to-list 'org-capture-templates (list "s"
                                                "Code snippets"
                                                'entry
                                                (list 'file
                                                      (locate-user-emacs-file "org/notes/snippets.org"))
                                                "* %? \n  #+begin_src %(my-get-source-buffers-mode)\n    %i\n  #+end_src\n\n"
                                                :empty-lines-after 2))
    #+end_src

*** Template for capturing appointments
    #+begin_src emacs-lisp
      (add-to-list 'org-capture-templates (list "a"
                                                "Appointment"
                                                'plain
                                                (list 'file
                                                      (locate-user-emacs-file "org/agenda/appt.org"))
                                                "* %? %^g\n  SCHEDULED: <%(org-read-date)>"))
    #+end_src

*** Template to capture a diary entry
    #+begin_src emacs-lisp
      (add-to-list 'org-capture-templates (list "d"
                                                "Diary"
                                                'plain
                                                (list 'file
                                                      (locate-user-emacs-file "org/diary"))
                                                "%(my-read-date-for-diary) %?\n\n"))
    #+end_src

*** Template for capturing habit
    #+begin_src emacs-lisp
      (add-to-list 'org-capture-templates (list "h" 
                                                "Habit" 
                                                'entry 
                                                (list 'file 
                                                      (locate-user-emacs-file "org/agenda/habits.org"))
                                                "* TODO %?\nSCHEDULED: <%<%Y-%m-%d .+1d/2d>>\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n"))
    #+end_src

*** Template for project specific TODOs
    #+begin_src emacs-lisp
      (require 'org-projectile)
      (add-to-list 'org-capture-templates 
        (org-projectile:project-todo-entry "p" "* TODO %? :%(my-get-source-buffers-project):\n%a\n"))
    #+end_src

*** Template for capturing journal entry
    #+begin_src emacs-lisp
      (add-to-list 'org-capture-templates (list "j"
                                                "Journal entry"
                                                'plain
                                                (list 'function #'my-find-journal-file)
                                                "** %(format-time-string org-journal-time-format)%?\n"))
    #+end_src

*** Template for capturing journal entry linked to given buffer
    #+begin_src emacs-lisp
      (add-to-list 'org-capture-templates (list "J"
                                                "Journal entry"
                                                'plain
                                                (list 'function #'my-find-journal-file)
                                                "** %(format-time-string org-journal-time-format)%?\n%(my-get-source-buffers-region-and-link 1)"))
    #+end_src

** Re-import elfeed feeds after capturing a feed
   #+begin_src emacs-lisp
     (defun my-maybe-reimport-feeds-after-capture ()
       (when (string= (org-capture-get :key) "f")
         (my-import-elfeed-feeds)))

     (add-hook 'org-capture-after-finalize-hook #'my-maybe-reimport-feeds-after-capture)
   #+end_src


* Custom agenda commands
  Command to view link log
  #+begin_src emacs-lisp
    (setq org-agenda-custom-commands
          `(("l" "View link log" ((todo "UNREAD")
                                  (todo "READING")
                                  (todo "READ"))
             ((org-agenda-files '(,(concat my-notes-dir "links.org")))))))
  #+end_src


* Configurations for org clocking
** Capture a note while clocking out
   #+begin_src emacs-lisp
     (setq org-log-note-clock-out t)
   #+end_src

** Better display of clocked in task, also indicate if not currently clocked in
   #+begin_src emacs-lisp
     (setq org-clock-clocked-in-display nil)

     (defface my-org-not-clocked-in
       `((t :background "red" :foreground "white" :weight bold))
       "Face for when you are not clocked in to an org task")

     (defface my-org-clocked-in
       `((t :background "LimeGreen" :foreground "white" :weight bold))
       "Face for when you are not clocked in to an org task")

     (defun my-org-clock-mode-line ()
       (when (org-clocking-p) (org-clock-update-mode-line))
       (let ((mode-line-string (concat " "
                                       (if (org-clocking-p)
                                           org-mode-line-string
                                         "Not clocked in")))
             (mode-line-face (if (org-clocking-p)
                                 'my-org-clocked-in
                               'my-org-not-clocked-in)))
         (concat (propertize (concat mode-line-string " ")
                             'face mode-line-face)
                 " ")))

     (setq global-mode-string (remove '(:eval (my-org-clock-mode-line)) global-mode-string))
     (push '(:eval (my-org-clock-mode-line))
           (cdr global-mode-string))
   #+end_src

** Store persistence info inside org directory
   #+begin_src emacs-lisp
     (setq org-clock-persist-file (locate-user-emacs-file "org/misc/org-clock-save.el"))

     (unless (file-exists-p (locate-user-emacs-file "org/misc"))
       (make-directory (locate-user-emacs-file "org/misc") t))
   #+end_src

** Save both the running clock, and the entire clock history on exiting emacs
  #+begin_src emacs-lisp
    (setq org-clock-persist t)
  #+end_src

** Always insert clocking info in *CLOCK* drawer
   #+begin_src emacs-lisp
     (setq org-clock-into-drawer "CLOCK")
   #+end_src

** Remove clock line if resulting time is zero
   #+begin_src emacs-lisp
     (setq org-clock-out-remove-zero-time-clocks t)
   #+end_src

** Do not find a recent task, if there is not current clocked in task in org-clock-goto
   #+begin_src emacs-lisp
     (setq org-clock-goto-may-find-recent-task nil)
   #+end_src

** Setup clock persistence
   #+begin_src emacs-lisp
     (org-clock-persistence-insinuate)
   #+end_src

** Automatically change todo states on clock-in and clock-out
   #+begin_src emacs-lisp
     (defun my-org-clock-in-switch (state)
       (cond ((string= state "UNREAD") "READING")
             ((string= state "READ") "READING")
             (t "STARTED")))

     (defun my-org-clock-out-switch (state)
       (cond ((string= state "READING") "UNREAD")
             ((string= state "STARTED") "TODO")))

     (setq org-clock-in-switch-to-state #'my-org-clock-in-switch)
     (setq org-clock-out-switch-to-state #'my-org-clock-out-switch)
   #+end_src

** View currently clocked in task
  #+begin_src emacs-lisp
    (defun my-org-hide/show-current-task ()
      (interactive)
      (let ((task-buffer-name "*Current Task*"))
        (if (string= (buffer-name) task-buffer-name)
            (ignore-errors (delete-window))
          (if (not (org-clocking-p))
              (error "Not clocked in to any task")
            (org-save-all-org-buffers)
            (select-window (or (get-buffer-window task-buffer-name)
                               (split-window (frame-root-window) nil 'right)))
            (when (get-buffer task-buffer-name)
              (kill-buffer (get-buffer task-buffer-name)))
            (org-clock-goto)
            (switch-to-buffer (clone-indirect-buffer task-buffer-name nil))
            (org-narrow-to-subtree)))))
  #+end_src

** Automatically clock out if task is marked as 'non-started' state
   #+begin_src emacs-lisp
     (setq org-clock-out-when-done '("TODO"
                                      "NEXT"
                                      "DONE"
                                      "WAITING"
                                      "HOLD"
                                      "CANCELLED"
                                      "READ"
                                      "UNREAD"))
   #+end_src


* Goto to a random task from global TODO list
  #+begin_src emacs-lisp
    (defun org-random-entry (&optional arg)
      "Select and goto a random todo item from the global agenda"
      (interactive "P")
      (if org-agenda-overriding-arguments
          (setq arg org-agenda-overriding-arguments))
      (if (and (stringp arg) (not (string-match "\\S-" arg))) (setq arg nil))
      (let* ((today (org-today))
             (date (calendar-gregorian-from-absolute today))
             (kwds org-todo-keywords-for-agenda)
             (lucky-entry nil)
             (completion-ignore-case t)
             (org-agenda-buffer (when (buffer-live-p org-agenda-buffer)
                                  org-agenda-buffer))
             (org-select-this-todo-keyword
              (if (stringp arg) arg
                (and arg (integerp arg) (> arg 0)
                     (nth (1- arg) kwds))))
             rtn rtnall files file pos marker buffer)
        (when (equal arg '(4))
          (setq org-select-this-todo-keyword
                (org-icompleting-read "Keyword (or KWD1|K2D2|...): "
                                      (mapcar 'list kwds) nil nil)))
        (and (equal 0 arg) (setq org-select-this-todo-keyword nil))
        (catch 'exit
          (org-compile-prefix-format 'todo)
          (org-set-sorting-strategy 'todo)
          (setq files (org-agenda-files nil 'ifmode)
                rtnall nil)
          (while (setq file (pop files))
            (catch 'nextfile
              (org-check-agenda-file file)
              (setq rtn (org-agenda-get-day-entries file date :todo))
              (setq rtnall (append rtnall rtn))))
          
          (when rtnall
            (setq lucky-entry
                  (nth (random
                        (safe-length
                         (setq entries rtnall)))
                       entries))
            
            (setq marker (or (get-text-property 0 'org-marker lucky-entry)
                             (org-agenda-error)))
            (setq buffer (marker-buffer marker))
            (setq pos (marker-position marker))
            (org-pop-to-buffer-same-window buffer)
            (widen)
            (goto-char pos)
            (when (derived-mode-p 'org-mode)
              (org-show-context 'agenda)
              (save-excursion
                (and (outline-next-heading)
                     (org-flag-heading nil))) ; show the next heading
              (when (outline-invisible-p)
                (show-entry))                 ; display invisible text
              (run-hooks 'org-agenda-after-show-hook))))))
  #+end_src


* Keybindings
** Global keybindings for org-mode
  #+begin_src emacs-lisp
    (global-set-key (kbd "C-c a") #'org-agenda)
    (global-set-key (kbd "C-c c") #'org-capture)

    (global-set-key (kbd "<f10>") #'org-todo-list)
    (global-set-key (kbd "<f8>") #'my-org-hide/show-current-task)
    (global-set-key (kbd "<f9>") #'org-tags-view)
    (global-set-key (kbd "<f7>") #'org-capture)
  #+end_src

** Keybinding to open/exit deft
   #+begin_src emacs-lisp
     (global-set-key (kbd "C-c n") #'deft)
     (eval-after-load "deft"
       '(define-key deft-mode-map (kbd "C-c n") #'quit-window))
   #+end_src

** Keybinding to view diary
   #+begin_src emacs-lisp
     (global-set-key (kbd "C-c D") #'diary)
   #+end_src
