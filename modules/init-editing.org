* Install some useful packages
+ [[https://github.com/winterTTr/ace-jump-mode/wiki][ace-jump-mode]] Move your cursor to ANY position in visible region quickly
+ [[http://www.dr-qubit.org/undo-tree/undo-tree-0.6.4.el][undo-tree]] - Represents your undo history as a tree and provides some really useful features
+ [[https://github.com/browse-kill-ring/browse-kill-ring][browse-kill-ring]] - Useful package for interacting with the kill ring visually
+ [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]] - Multiple cursors for emacs.
+ [[https://github.com/abo-abo/tiny][tiny]] - Quickly generate linear ranges in Emacs
+ [[https://github.com/magnars/expand-region.el][expand-region]] - Emacs extension to increase selected region by semantic units.
+ [[https://github.com/nflath/hungry-delete][hungry-delete]] - Get hungry delete everywhere

#+begin_src emacs-lisp
  (defvar iqbal-editing-packages
    '(undo-tree
      browse-kill-ring
      multiple-cursors
      tiny
      expand-region
      hungry-delete))
  
  (el-get 'sync iqbal-editing-packages)  
#+end_src   


* Always use spaces to indent and use four space
  #+begin_src emacs-lisp
    (setq-default indent-tabs-mode nil)
    (setq tab-stop-list (number-sequence 4 200 4))
  #+end_src


* Enable subword mode globally
  #+begin_src emacs-lisp
    (global-subword-mode 1)
  #+end_src


* Replace selected region with typed text
  #+begin_src emacs-lisp
    (delete-selection-mode)
  #+end_src


* Multiple cursors setup
  Keybindings for multiple cursors
  #+begin_src emacs-lisp
    (global-set-key (kbd "C-S-m") 'mc/mark-more-like-this-extended)
    (global-set-key (kbd "C-S-l") 'mc/edit-lines)
    (global-set-key (kbd "C-S-c") 'mc/mark-all-like-this-dwim)
    (global-set-key (kbd "C-S-<mouse-1>") 'mc/add-cursor-on-click)
    (global-set-key (kbd "C-S-r") 'set-rectangular-region-anchor)
    (global-set-key (kbd "C-S-a") 'mc/mark-all-in-region)
  #+end_src
  

* Tiny setup
  Keybindings for expanding tiny expressions
  #+begin_src emacs-lisp
    (autoload 'tiny-expand "tiny")
    (global-set-key (kbd "C-:") 'tiny-expand)
  #+end_src
  
       	       	   
* Expand region setup
  #+begin_src emacs-lisp
    (global-set-key (kbd "C-=") 'er/expand-region)
    (global-set-key (kbd "C--") 'er/contract-region)
  #+end_src
  

* Prompt for user input during macro execution
  Following was borrowed from [[http://www.emacswiki.org/emacs/KeyboardMacros#toc5][emacswiki]], Pressing ‘C-x Q’ during macro
  definition will present you with a minibuffer prompt (using
  recursive edit). Inserting some text and pressing RET will end
  recursive edit and continue the definition of the macro in the
  minibuffer. Pressing RET again will insert the entered text at
  point. If you don’t want to insert the text right away you can
  instead kill the input at this point (using ‘C-a C-k RET’) and use
  it later in the macro definition.
  #+begin_src emacs-lisp
    (defun my-macro-query (arg)
      "Prompt for input using minibuffer during kbd macro execution.
        With prefix argument, allows you to select what prompt string to use.
        If the input is non-empty, it is inserted at point."
      (interactive "P")
      (let* ((prompt (if arg (read-from-minibuffer "PROMPT: ") "Input: "))
             (input (minibuffer-with-setup-hook (lambda () (kbd-macro-query t))
                      (read-from-minibuffer prompt))))
        (unless (string= "" input) (insert input))))
    (global-set-key "\C-xQ" 'my-macro-query)
  #+end_src
  

* Undo tree setup
** Keep the region active when undoing in a region
   #+begin_src emacs-lisp
     (defadvice undo-tree-undo (around keep-region activate)
       (if (use-region-p)
           (let ((m (set-marker (make-marker) (mark)))
                 (p (set-marker (make-marker) (point))))
             ad-do-it
             (goto-char p)
             (set-mark m)
             (set-marker p nil)
             (set-marker m nil))
         ad-do-it))
   #+end_src

** Enable undo-tree globally
  #+begin_src emacs-lisp
    (global-undo-tree-mode)
  #+end_src
  

* Browse kill ring setup
** Keybindings for browse kill ring
  #+begin_src emacs-lisp
    (autoload 'browse-kill-ring "browse-kill-ring")
    (global-set-key (kbd "C-c M-y") 'browse-kill-ring)
  #+end_src
  
** Do not show duplicates in kill-ring
   #+begin_src emacs-lisp
     (setq browse-kill-ring-display-duplicates nil)
   #+end_src

** Don't highlight current candidate in kill-ring
   #+begin_src emacs-lisp
     (setq browse-kill-ring-highlight-inserted-item nil)
   #+end_src

** Display maximum of 100 characters per entry in kill-ring
   #+begin_src emacs-lisp
     (setq browse-kill-ring-maximum-display-length 100)
   #+end_src

** Do not add duplicates to kill-ring
   #+begin_src emacs-lisp
     (setq browse-kill-ring-no-duplicates t)
     (eval-after-load "browse-kill-ring"
       '(progn (ad-enable-advice 'kill-new 'around 'browse-kill-ring-no-kill-new-duplicates)
              (ad-activate 'kill-new)))
   #+end_src

** Always keep the current entry in kill ring at the top
   #+begin_src emacs-lisp
     (setq browse-kill-ring-recenter t)
   #+end_src


* Toggle comment region or line if no region is selected
  #+begin_src emacs-lisp
    (defun comment-or-uncomment-region-or-line ()
        "Comments or uncomments the region or the current line if there's no active region."
        (interactive)
        (let (beg end)
            (if (region-active-p)
                (setq beg (region-beginning) end (region-end))
                (setq beg (line-beginning-position) end (line-end-position)))
            (comment-or-uncomment-region beg end)
            (forward-line)))
    (global-set-key (kbd "M-;") 'comment-or-uncomment-region-or-line)
  #+end_src


* Show all lines matching REGEXP in buffers with this major mode. Taken from
  [[http://www.masteringemacs.org/articles/2011/07/20/searching-buffers-occur-mode/][mastering-emacs]]
  #+begin_src emacs-lisp
    (eval-when-compile
      (load  "cl"))
    
    ;; Get lines matching REGEXP in all buffers with this major mode
    (defun get-buffers-matching-mode (mode)
      "Returns a list of buffers where their major-mode is equal to MODE"
      (let ((buffer-mode-matches '()))
        (dolist (buf (buffer-list))
          (with-current-buffer buf
            (if (eq mode major-mode)
                (add-to-list 'buffer-mode-matches buf))))
        buffer-mode-matches))
    
    (defun multi-occur-in-this-mode ()
      "Show all lines matching REGEXP in buffers with this major mode."
      (interactive)
      (multi-occur
       (get-buffers-matching-mode major-mode)
       (car (occur-read-primary-args))))
    
    (global-set-key (kbd "M-o") 'multi-occur-in-this-mode)
  #+end_src


* Keybindings to highlight text according to regexp
  #+begin_src emacs-lisp
    (global-set-key (kbd "C-c h l") 'highlight-lines-matching-regexp)
    (global-set-key (kbd "C-c h w") 'highlight-regexp)
    (global-set-key (kbd "C-c h r") 'unhighlight-regexp)
  #+end_src


* Copy/cut current line if no region is selected
  #+begin_src emacs-lisp
    (defun iqbal-mark-lines(arg)
      (back-to-indentation)
      (set-mark-command nil)
      (move-end-of-line arg))
    
    (defun copy-line-or-region (arg)
      "Copy current line, or current text selection."
      (interactive "p")
      (if (region-active-p)
          (progn
            (call-interactively 'kill-ring-save)
            (indicate-copied-region))
        (let ((cur-pos (point)))
          (iqbal-mark-lines arg)
          (call-interactively 'kill-ring-save)
          (deactivate-mark t)
          (goto-char cur-pos)
          (message (concat "Saved " 
                           (number-to-string arg)
                           " line(s) to kill ring")))))
    
    (defun cut-line-or-region (arg)
      "Cut the current line, or current text selection."
      (interactive "p")
      (if (region-active-p)
          (call-interactively 'kill-region)
        (iqbal-mark-lines arg)
        (call-interactively 'kill-region)
        (message (concat "Killed " (number-to-string arg) " line(s)"))))
    
    (global-set-key (kbd "M-w") 'copy-line-or-region)
    (global-set-key (kbd "C-w") 'cut-line-or-region)
  #+end_src


* Keybinding to join lines
  #+begin_src emacs-lisp
    (global-set-key (kbd "M-j")
            (lambda ()
                  (interactive)
                  (join-line -1)))
  #+end_src


* Keybindings to move quickly
  Move by then units by using ctrl + shift + [npfb]
  #+begin_src emacs-lisp
    (global-set-key (kbd "C-S-n")
                    (lambda ()
                      (interactive)
                      (ignore-errors (forward-line 10))))
    
    (global-set-key (kbd "C-S-p")
                    (lambda ()
                      (interactive)
                      (ignore-errors (forward-line -10))))
    
    (global-set-key (kbd "C-S-f")
                    (lambda ()
                      (interactive)
                      (ignore-errors (forward-char 10))))
    
    (global-set-key (kbd "C-S-b")
                    (lambda ()
                      (interactive)
                      (ignore-errors (backward-char 10))))
    
  #+end_src
  
  

* Keybinding for duplicate current line or region
  Duplicate current line if region is not selected else duplicate the region
  pressing 'd' immediately after duplicating a line will duplicate the line
  again. 
  #+begin_src emacs-lisp
    (defun duplicate-current-line-or-region (arg)
      "Duplicates the current line or region ARG times.
    If there's no region, the current line will be duplicated."
      (interactive "p")
      (if (region-active-p)
          (lexical-let ((beg (region-beginning))
                (end (region-end)))
            (duplicate-region arg beg end)
            (one-shot-keybinding "d" (lambda ()
                                       (interactive)
                                       (duplicate-region 1 beg end))))
        (duplicate-current-line arg)
        (one-shot-keybinding "d" 'duplicate-current-line)))
    
    (defun duplicate-region (&optional num start end)
      "Duplicates the region bounded by START and END NUM times.
    If no START and END is provided, the current region-beginning and
    region-end is used."
      (interactive "p")
      (save-excursion
        (let* ((start (or start (region-beginning)))
               (end (or end (region-end)))
               (region (buffer-substring start end)))
          (goto-char end)
          (dotimes (i num)
            (insert region)))))
    
    (defun duplicate-current-line (&optional num)
      "Duplicate the current line NUM times."
      (interactive "p")
      (save-excursion
        (when (eq (point-at-eol) (point-max))
          (goto-char (point-max))
          (newline)
          (forward-char -1))
        (duplicate-region num (point-at-bol) (1+ (point-at-eol)))))
    
    (global-set-key (kbd "C-x d") 'duplicate-current-line-or-region)
  #+end_src
  

* Convenient functions for opening newlines
  Typing shift + return anywhere on a line will create a new line
  below the current line, ctrl + shift + return will open a line above
  M-RET between parenthesis will insert an newline between the parenthesis
  #+begin_src emacs-lisp
    (defun open-line-below ()
      (interactive)
      (end-of-line)
      (newline)
      (indent-for-tab-command))
    
    (defun open-line-above ()
      (interactive)
      (beginning-of-line)
      (newline)
      (forward-line -1)
      (indent-for-tab-command))
    
    
    (defun new-line-dwim ()
      (interactive)
      (let ((break-open-pair (or (and (looking-back "{") (looking-at "}"))
                                 (and (looking-back ">") (looking-at "<"))
                                 (and (looking-back "\\[") (looking-at "\\]")))))
        (newline)
        (when break-open-pair
          (save-excursion
            (newline)
            (indent-for-tab-command)))
        (indent-for-tab-command)))
    
    
    (global-set-key (kbd "<C-return>") 'open-line-below)
    (global-set-key (kbd "<C-S-return>") 'open-line-above)
    (global-set-key (kbd "<M-return>") 'new-line-dwim)
  #+end_src

  
* Keybindings for killing backwards
  Pressing shift with usual keys will reverse the operations
  #+begin_src emacs-lisp
    (defun backward-kill-line (arg)
      "Kill ARG lines backward."
      (interactive "p")
      (kill-line (- 1 arg)))
    
    (global-set-key (kbd "C-S-k") 'backward-kill-line)
    
    (global-set-key (kbd "M-D") 'backward-kill-word)
    
    (global-set-key (kbd "C-S-d") 'backward-delete-char-untabify)
    
  #+end_src


* Functions to increment and decrement integers at point
  These were borrowed from prelude
  #+begin_src emacs-lisp
    (load  "thingatpt")
    
    (defun thing-at-point-goto-end-of-integer ()
      "Go to end of integer at point."
      (let ((inhibit-changing-match-data t))
        ;; Skip over optional sign
        (when (looking-at "[+-]")
          (forward-char 1))
        ;; Skip over digits
        (skip-chars-forward "[[:digit:]]")
        ;; Check for at least one digit
        (unless (looking-back "[[:digit:]]")
          (error "No integer here"))))
    (put 'integer 'beginning-op 'thing-at-point-goto-end-of-integer)
    
    (defun thing-at-point-goto-beginning-of-integer ()
      "Go to end of integer at point."
      (let ((inhibit-changing-match-data t))
        ;; Skip backward over digits
        (skip-chars-backward "[[:digit:]]")
        ;; Check for digits and optional sign
        (unless (looking-at "[+-]?[[:digit:]]")
          (error "No integer here"))
        ;; Skip backward over optional sign
        (when (looking-back "[+-]")
          (backward-char 1))))
    (put 'integer 'beginning-op 'thing-at-point-goto-beginning-of-integer)
    
    (defun thing-at-point-bounds-of-integer-at-point ()
      "Get boundaries of integer at point."
      (save-excursion
        (let (beg end)
          (thing-at-point-goto-beginning-of-integer)
          (setq beg (point))
          (thing-at-point-goto-end-of-integer)
          (setq end (point))
          (cons beg end))))
    (put 'integer 'bounds-of-thing-at-point 'thing-at-point-bounds-of-integer-at-point)
    
    (defun thing-at-point-integer-at-point ()
      "Get integer at point."
      (let ((bounds (bounds-of-thing-at-point 'integer)))
        (string-to-number (buffer-substring (car bounds) (cdr bounds)))))
    (put 'integer 'thing-at-point 'thing-at-point-integer-at-point)
    
    (defun increment-integer-at-point (&optional inc)
      "Increment integer at point by one.
    
    With numeric prefix arg INC, increment the integer by INC amount."
      (interactive "p")
      (let ((inc (or inc 1))
            (n (thing-at-point 'integer))
            (bounds (bounds-of-thing-at-point 'integer)))
        (delete-region (car bounds) (cdr bounds))
        (insert (int-to-string (+ n inc)))))
    
    (defun decrement-integer-at-point (&optional dec)
      "Decrement integer at point by one.
    
    With numeric prefix arg DEC, decrement the integer by DEC amount."
      (interactive "p")
      (increment-integer-at-point (- (or dec 1))))
    
    (global-set-key (kbd "C-c +") 'increment-integer-at-point)
    (global-set-key (kbd "C-c -") 'decrement-integer-at-point)
  #+end_src


* Keybindings for navigating between errors
  #+begin_src emacs-lisp
    (global-set-key (kbd "M-n") 'next-error)
    (global-set-key (kbd "M-p") 'previous-error)
  #+end_src


* Auto-indent on yanked text taken from [[http://www.emacswiki.org/emacs/AutoIndentation#toc3][emacswiki]]
  #+begin_src emacs-lisp
    (dolist (command '(yank yank-pop))
       (eval `(defadvice ,command (after indent-region activate)
                (and (not current-prefix-arg)
                     (member major-mode '(emacs-lisp-mode lisp-mode
                                                          clojure-mode    scheme-mode
                                                          haskell-mode    ruby-mode
                                                          rspec-mode      python-mode
                                                          c-mode          c++-mode
                                                          objc-mode       latex-mode
                                                          plain-tex-mode))
                     (let ((mark-even-if-inactive transient-mark-mode))
                       (indent-region (region-beginning) (region-end) nil))))))
  #+end_src


* Keybindings for hungry deletion
  #+begin_src emacs-lisp
    (autoload 'hungry-delete-forward "hungry-delete")
    (autoload 'hungry-delete-backward "hungry-delete")
    (global-set-key (kbd "C-c DEL") 'hungry-delete-backward)
    (global-set-key (kbd "C-c <deletechar>") 'hungry-delete-forward)
  #+end_src
