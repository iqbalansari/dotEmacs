* Declare global variables and utility functions
  Set global variables to be used in the rest of the intialization
** 1. The full path to emacs.d
   This is needed sometimes (eg. for ternjs on windows)
   #+begin_src emacs-lisp
     (defvar my-home-dir (concat (expand-file-name "~/.emacs.d/")))
   #+end_src
   
** 2. Path to 'non-el-get' packages
  Packages not currently installable via el-get reside in this directory
  #+begin_src emacs-lisp
    (defvar otherpackages "~/.emacs.d/otherpackages/")
  #+end_src

** 3. Path to 'lang'uage specific configurations
   Lang contain the configuration related to one specific type of file.
   They reside in the following directory
   #+begin_src emacs-lisp
     (defvar my-langs-dir "~/.emacs.d/lang/")
   #+end_src

** 4. Check if given file is older than any of the other given files
   #+begin_src emacs-lisp
     (defun my-is-file-stale (orig-file &rest files)
       (if (file-exists-p orig-file)
           (reduce (lambda (is-stale-yet? file)
                     (or is-stale-yet?
                         (file-newer-than-file-p file orig-file)))
                   files
                   :initial-value nil)
         t))
   #+end_src

** 5. Helper functions to read/write from/to file
   #+begin_src emacs-lisp
     (defun my-read-file (path)
       (with-temp-buffer
         (insert-file-contents-literally path)
         (buffer-substring-no-properties (point-min) (point-max))))
     
     (defun my-write-to-file (file data)
       (with-temp-file file
         (erase-buffer)
         (insert data)))
   #+end_src

** 6. Function to load language configuration
   A simple helper function to load a particular language configuration.
   Instead of loading the org files one by one it combines all the code in
   them in one compiled file and loads that file, the compiled file is regenerated
   if any of the org files change
   #+begin_src emacs-lisp
     (defun my-install-lang (language)
       (interactive 
        (list (ido-completing-read "Language: " 
                                   (directory-files my-langs-dir nil "[^.]+"))))
       
       (let ((install-file (concat my-langs-dir 
                                   language "/install.org")))
         (when (file-exists-p install-file)
           (org-babel-load-file install-file))))
     
     (defun my-compile-lang-config (lang)
       (let* ((files '("install" "setup" "keybindings"))
              (lang-path (concat my-langs-dir lang "/"))
              (compiled-file-dest (concat lang-path ".compiled/"))
              (compiled-file (concat compiled-file-dest ".combined.el")))
         
         (unless (file-exists-p compiled-file-dest)
           (make-directory compiled-file-dest))
         
         (my-write-to-file compiled-file 
                           (loop for file in files
                                 when (file-exists-p (concat lang-path file ".org"))
                                 concat (my-read-file (car (org-babel-tangle-file 
                                                            (concat lang-path file ".org")
                                                            (concat compiled-file-dest file ".el")
                                                            "emacs-lisp")))))
         (byte-compile-file compiled-file)))
     
     (defun my-load-lang (language)
       (interactive 
        (list (ido-completing-read "Language: " 
                                   (directory-files my-langs-dir nil "[^.]+"))))
       (let* ((files '("install" "setup" "keybindings"))
              (lang-path (concat my-langs-dir language "/"))
              (compiled-file-dest (concat lang-path ".compiled/"))
              (compiled-file (concat compiled-file-dest ".combined.el")))
         
         (when (apply #'my-is-file-stale compiled-file 
                      (loop for file in files 
                            when (file-exists-p (concat lang-path file ".org"))
                            collect (concat lang-path file ".org")))
           (my-compile-lang-config language))
         
         (load-file compiled-file)))
     
     
     (defun my-compile-all-lang-config ()
       (interactive)
       (dolist (lang (directory-files my-langs-dir nil "[^.]+"))
         (my-compile-lang-config lang)))
   #+end_src

** 7. Function to declare one-shot keybindings
    These bindings active only after a particular command and are
    deactivated as soon as some other key is pressed (as in 'C-x e'
    and 'e'). Borrowed from [[https://github.com/magnars/.emacs.d][Magnar Sveen's .emacs.d]]
    #+begin_src emacs-lisp
      (defun one-shot-keybinding (key command)
        (set-temporary-overlay-map
         (let ((map (make-sparse-keymap)))
           (define-key map (kbd key) command)
           map) t))
    #+end_src

** 8. Interacting with REPL
   #+begin_src emacs-lisp
     (defmacro my-evaluate-line-in-repl (name send-string-func)
       `(defun ,name ()
          (interactive)
          (,send-string-func (buffer-substring (line-beginning-position)
                                                    (line-end-position)))))
     
     (defmacro my-evaluate-file-in-repl (name send-string-func)
       `(defun ,name (file)
          (interactive (list (ido-read-file-name "File to evaluate: ")))
          (,send-string-func (my-read-file file))))
     
     (defmacro my-evaluate-buffer-in-repl (name send-string-func)
       `(defun ,name ()
          (interactive)
          (,send-string-func (buffer-string))))
     
     (defmacro my-evaluate-defun-in-repl (name send-string-func)
       `(defun ,name ()
          (interactive)
          (let ((start (save-excursion (beginning-of-defun) (point)))
                (end   (save-excursion (end-of-defun) (point))))
            (,send-string-func (buffer-substring start
                                                 end)))))     
   #+end_src

** 9. Highlighting the line to reorient the user
   #+begin_src emacs-lisp
     (defun my-highlight-line ()
       (require 'pulse)
       (pulse-momentary-highlight-one-line (point)))
     
     (defmacro my-highlight-line-after-func (func)
       `(progn (defadvice ,func (after highlight-current-line
                                            (&rest args))
                 "Flash the current line after jump"
                 (sit-for 0.1)
                 (my-highlight-line))
               (ad-activate ',func)))
   #+end_src


* Unbind keys
** Unset C-z, I don't find it useful
   #+begin_src emacs-lisp
     (global-unset-key "\C-z")
   #+end_src

** Unset C-x C-c to avoid killing emacs mistakenly
   #+begin_src emacs-lisp
     (global-unset-key (kbd "C-x C-c"))
     (global-set-key (kbd "C-x r q") 'save-buffers-kill-emacs)
   #+end_src

   

* Enable some disable commands
  #+begin_src emacs-lisp
    (put 'narrow-to-region 'disabled nil)
    (put 'scroll-left 'disabled nil)
  #+end_src


* Integration with system clipboard
** Use system clipboard, these are helpful only when running GUI emacs
  #+begin_src emacs-lisp
    (setq x-select-enable-clipboard t)
    (setq save-interprogram-paste-before-kill t)
  #+end_src

** Use 'xsel' for kill and yank on emacs run in terminal
   #+begin_src emacs-lisp
     (unless window-system
       (when (getenv "DISPLAY")
         (if (executable-find "xsel")
             (progn
               ;; Callback for when user cuts
               (defun xsel-cut-function (text &optional push)
                 ;; Insert text to temp-buffer, and "send" content to xsel stdin
                 (with-temp-buffer
                   (insert text)
                   ;; I prefer using the "clipboard" selection (the one the
                   ;; typically is used by c-c/c-v) before the primary selection
                   ;; (that uses mouse-select/middle-button-click)
                   (call-process-region (point-min) (point-max) "xsel" nil 0 nil "--clipboard" "--input")))
               ;; Call back for when user pastes
               (defun xsel-paste-function()
                 ;; Find out what is current selection by xsel. If it is different
                 ;; from the top of the kill-ring (car kill-ring), then return
                 ;; it. Else, nil is returned, so whatever is in the top of the
                 ;; kill-ring will be used.
                 (let ((xsel-output (shell-command-to-string "xsel --clipboard --output")))
                   (unless (string= (car kill-ring) xsel-output)
                     xsel-output )))
               ;; Attach callbacks to hooks
               (setq interprogram-cut-function 'xsel-cut-function)
               (setq interprogram-paste-function 'xsel-paste-function))
           (message "Install `xsel' for integrating copy-paste between emacs run in terminal and other programs"))))
   #+end_src


* Replace yes-no questions with y-n questions
  #+begin_src emacs-lisp
    (fset 'yes-or-no-p 'y-or-n-p)
  #+end_src
  

* Create auto-save directory if it does not already exist
  #+begin_src emacs-lisp
    (unless (file-exists-p "~/.emacs.d/auto-save/")
      (make-directory "~/.emacs.d/auto-save/"))
  #+end_src

  
* Declare common keybindings
  These don't actually bind any command rather they define the keys that will 
  be used for common actions across multiple modes for commands 
  like jumping-to-definition etc. These keys will be bound to actual 
  functions by the respective major modes.

** Jumping to definitions
   #+begin_src emacs-lisp
     (defvar my-jump-to-definition (kbd "M-."))
     (defvar my-pop-jump-to-definition-marker (kbd "M-,"))
   #+end_src

** Finding references
   #+begin_src emacs-lisp
     (defvar my-find-references (kbd "C-<"))
   #+end_src

** Displaying doc
   #+begin_src emacs-lisp
     (defvar my-show-doc (kbd "C-c d"))
   #+end_src

** Refactoring
   #+begin_src emacs-lisp     
     (defvar my-refactor-rename (kbd "C-c r"))
     (defvar my-refactor-auto-import (kbd "C-c i"))
     (defvar my-refactor-organize-imports (kbd "C-c o"))
   #+end_src

** Interacting with REPL
   #+begin_src emacs-lisp
     (defvar my-run-shell (kbd "C-c C-z"))
     (defvar my-send-region (kbd "C-c C-r"))
     (defvar my-send-buffer (kbd "C-c C-b"))
     (defvar my-send-line (kbd "C-c C-l"))
     (defvar my-send-file (kbd "C-c C-f"))
     (defvar my-send-function (kbd "C-M-x"))
     (defvar my-send-phrase/sexp/block (kbd "C-c C-e"))
   #+end_src

   
* Bootstrap el-get 
  Install El-Get is not installed and configure it
** Initialize El-Get
   #+begin_src emacs-lisp
     (add-to-list 'load-path "~/.emacs.d/el-get/el-get")
     
     (unless (require 'el-get nil 'noerror)
       (with-current-buffer
           (url-retrieve-synchronously
            "https://raw.github.com/dimitri/el-get/master/el-get-install.el")
         (let (el-get-master-branch)
           (goto-char (point-max))
           (eval-print-last-sexp))))
   #+end_src
   
** Path to El-Get recipies
   Use recipies from this directory
   #+begin_src emacs-lisp
       (add-to-list 'el-get-recipe-path "~/.emacs.d/recipies/")
   #+end_src

** Start El-Get   
   #+begin_src emacs-lisp
     (el-get 'sync)
   #+end_src
   

* Initialize package management
  Initialize package manager and add repositories
  #+begin_src emacs-lisp
      (add-to-list 'package-archives
                 '("melpa" . "http://melpa.milkbox.net/packages/") t)
      (add-to-list 'package-archives
                 '("marmalade" . "http://marmalade-repo.org/packages/") t)
      (add-to-list 'package-archives
			     '("geiser" . "http://download.savannah.gnu.org/releases/geiser/packages"))
  #+end_src


* Configurations for Emacs lisp
  Loading emacs-lisp configurations here since loading it via
  org-babel-load-file can lead to circular loading. org-babel-load-file
  internally uses find-file for its operations. This problematic in our case
  since it leads to loading emacs-lisp mode and since we load the configs in
  emacs-lisp-mode hook this agains triggers the loading of our
  emacs-lisp-config.
  #+begin_src emacs-lisp
    (defvar my-elisp-packages
      '(el-spice))
    
    (el-get 'sync my-elisp-packages)
    
    (add-hook 'emacs-lisp-mode-hook 'el-spice-mode)
    (add-hook 'lisp-interaction-mode-hook 'el-spice-mode)
  #+end_src
  

* Configure loading of the major modes
** C
   #+begin_src emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.c\\'" . (lambda ()
                                                   (my-load-lang "c"))))
   #+end_src

** Python
  #+begin_src emacs-lisp
    (add-hook 'python-mode-hook (lambda ()
                                  (my-load-lang "python")))
  #+end_src

** Javascript
   #+begin_src emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.js\\'" . (lambda ()
                                                    (my-load-lang "javascript"))))
   #+end_src

** HTML mode
   #+begin_src emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.html\\'" . (lambda ()
                                                      (my-load-lang "html"))))
   #+end_src  

** CSS mode
  #+begin_src emacs-lisp
    (add-hook 'css-mode-hook (lambda ()
                                  (my-load-lang "css")))
  #+end_src
  
** Scheme mode
   #+begin_src emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.rkt\\'" . scheme-mode))
     
     (add-hook 'scheme-mode-hook (lambda ()
                                (my-load-lang "scheme")))
   #+end_src

** Common-lisp mode
   #+begin_src emacs-lisp
     (add-hook 'lisp-mode-hook (lambda ()
                                (my-load-lang "common-lisp")))
   #+end_src
   
** SML mode
   #+begin_src emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.\\(sml\\|sig\\)\\'" . (lambda ()
                                                                 (my-load-lang "sml"))))
   #+end_src

** OCaml mode
   #+begin_src emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.ml[iylp]?" . (lambda ()
                                                        (my-load-lang "ocaml"))))
   #+end_src

** Better mode for working with JSON
   #+begin_src emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.json\\'" . (lambda ()
                                                      (my-load-lang "json"))))
   #+end_src

** Markdown mode
   #+begin_src emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.markdown\\'" . (lambda ()
                                                          (my-load-lang "markdown"))))
     (add-to-list 'auto-mode-alist '("\\.md\\'" . (lambda ()
                                                    (my-load-lang "markdown"))))
   #+end_src

** Apache
   #+begin_src emacs-lisp
     (defun my-load-apache-conf ()
       (my-load-lang "apache"))
     (add-to-list 'auto-mode-alist '("\\.htaccess\\'"   . my-load-apache-conf))
     (add-to-list 'auto-mode-alist '("httpd\\.conf\\'"  . my-load-apache-conf))
     (add-to-list 'auto-mode-alist '("srm\\.conf\\'"    . my-load-apache-conf))
     (add-to-list 'auto-mode-alist '("access\\.conf\\'" . my-load-apache-conf))
     (add-to-list 'auto-mode-alist '("sites-\\(available\\|enabled\\)/" . my-load-apache-conf))     
   #+end_src

** Scala
   #+begin_src emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.\\(scala\\|sbt\\)\\'" . (lambda ()
                                                      (my-load-lang "scala"))))
   #+end_src

** Ruby
  #+begin_src emacs-lisp
    (add-hook 'ruby-mode-hook (lambda ()
                                  (my-load-lang "ruby")))
  #+end_src


* Load common libraries
   These are general purpose libraries that can are used
   by different modes

   The libaries are loaded by the file 'modules/init-modules.org'
   #+begin_src emacs-lisp
     (when (file-newer-than-file-p "~/.emacs.d/modules/init-modules.org" 
                                   "~/.emacs.d/modules/.compiled/init-modules.el")
       (org-babel-tangle-file "~/.emacs.d/modules/init-modules.org"
                              "~/.emacs.d/modules/.compiled/init-modules.el"
                              "emacs-lisp"))

     (load-file "~/.emacs.d/modules/.compiled/init-modules.el")
   #+end_src
   
